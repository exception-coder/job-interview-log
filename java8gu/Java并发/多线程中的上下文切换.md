## 1）10 行极简速记版（小红书爆款风）

✔ 上下文切换 = CPU 换线程时的“记忆恢复术”
🔥 多线程越多，切换越频繁，性能越被吞噬
📌 时间片耗尽 ≠ 线程结束，而是立即被换走
🧠 切换成本来自寄存器、PC、栈指针的保存与恢复
⚠️ 切得越勤，CPU 真正干活的时间越少
📈 无锁/CAS/虚拟线程 = 降低切换但无法彻底消灭
🚀 线程池不是多多益善，减少线程数反而更快
✨ 阻塞 = 强迫切换，I/O 多时更明显
➤ 同步块过大 = 线程排队 = 切换风暴
🔍 本质：OS 调度机制导致的“CPU 碎片化”

## 2）折叠式知识卡片版

<details>
<summary>定义</summary>

上下文切换：CPU 在多个线程间切换执行时，保存当前线程的运行状态（PC、寄存器、栈指针等），并恢复目标线程的状态，使其能继续从中断位置正确运行。

</details>

<details>
<summary>原理</summary>

* 多线程共享 CPU，基于时间片轮转调度；时间片用尽或遇到阻塞即触发切换。
* 切换过程需保存 TCB 关键状态，并加载下一个线程的执行环境。
* 保存与恢复状态引入额外开销，切换越频繁，CPU 有效工作时间越低。
* 虚拟线程使用用户态调度，避免操作系统级切换，但 JVM 仍需保存轻量级状态。

</details>

<details>
<summary>关键点</summary>

* 上下文切换是并发系统的核心成本之一。
* 线程数过多会导致频繁抢占，从而恶化性能。
* 阻塞操作（锁等待、I/O）会直接导致切换。
* 减少切换可通过减少阻塞、降低线程数、缩小同步范围、使用无锁/CAS。
* 虚拟线程优化的是切换成本，不是调度逻辑本质。

</details>

<details>
<summary>扩展知识</summary>

文档未覆盖，但可合理补充：

* 多核 CPU 可减少切换，但线程数仍不宜远超核心数。
* Java 中的线程调度受 OS 决定，JVM 无法绕过 OS 的抢占策略（虚拟线程除外）。

</details>

## 3）面试官追问（Q&A）

问：上下文切换会带来什么消耗？
答：需要保存/恢复寄存器、PC、栈指针等状态，导致缓存失效、TLB 失效，增加 CPU 额外负担。

问：为什么线程越多，性能可能越差？
答：线程大量争抢 CPU，频繁被抢占，导致切换次数指数级上升，真正执行逻辑的时间减少。

问：阻塞操作如何触发上下文切换？
答：线程阻塞时无法继续执行，OS 将其挂起并调度其他线程运行，强制发生切换。

问：无锁编程如何减少切换？
答：避免线程等待锁，从而避免阻塞和唤醒，减少调度器介入。

问：CAS 是否完全无线程切换？
答：非阻塞但失败重试仍有成本，但不会触发 OS 级挂起，因此切换较少。

问：虚拟线程如何减少开销？
答：用户态调度，不参与 OS 内核态切换，保存与恢复线程状态更轻量。

问：线程池如何影响切换？
答：合理线程数避免过量争抢 CPU，从而减少调度次数。

问：如何判断系统是否被上下文切换拖慢？
答：观察上下文切换指标（cs/s）、平均负载、CPU 使用率与实际吞吐不匹配等信号。

## 4）示意图（ASCII）

```
CPU 调度模型（简化）
┌───────────────┐
│      CPU       │
└───────┬─────────┘
        │ 时间片耗尽/阻塞
        ▼
┌─────────────────┐
│ 保存当前线程状态 │  ← PC/寄存器/栈指针
└─────────────────┘
        │
        ▼
┌─────────────────┐
│ 恢复目标线程状态 │
└─────────────────┘
        │
        ▼
   继续执行线程
```
