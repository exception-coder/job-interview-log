## 1）10 行极简速记版（小红书爆款风）

✔ 并发 = 单核假装“多线程一起跑”的幻术
🔥 并行 = 多核真·同时干活，硬件实力说话
📌 并发靠时间片轮转，本质是“轮流装同时”
🚀 并行靠多 CPU/多核，“两台咖啡机同时出杯”
🧠 单核永远只有并发，没有并行的命
✨ 并发关注“任务切换”，并行关注“任务同时执行”
📈 并发提升吞吐，并行提升性能
⚠️ 时间片分得越细，看起来越像并行但成本也越高
🔍 并发有争抢，并行资源隔离更纯粹
➤ 并发是模型，并行是能力，两者非对立而是互补

## 2）折叠式知识卡片版

<details>
<summary>定义</summary>

* **并发（Concurrency）**：单 CPU 在时间段内交替执行多个任务，通过时间片让多个程序看起来“同时运行”。
* **并行（Parallelism）**：多个 CPU 或多核同时处理不同任务，真正意义上的同时执行。

</details>

<details>
<summary>原理</summary>

* 并发依赖分时操作系统，将 CPU 划分为多个时间片并按轮转调度。
* 单 CPU 任一时刻只能执行一个任务，因此利用高速切换制造“同时执行”的错觉。
* 并行基于多核硬件，每个核心可以独立执行不同线程，无需抢占同一 CPU。
* 两者可组合：系统可同时并行执行多个并发任务组。

</details>

<details>
<summary>关键点</summary>

* 并发强调“调度策略”，并行强调“硬件能力”。
* 单核只能并发，多核既能并发又能并行。
* 并发任务间需争抢 CPU；并行任务间属于物理隔离，不争抢同一个核。
* 并发提升系统吞吐量，并行提升处理速度。

</details>

<details>
<summary>扩展知识</summary>

文档未提及，可合理补充：

* 并发模型常见实现：线程、协程、事件驱动模型。
* 并行模型常用于数据密集型场景，如 MapReduce、GPU 运算。

</details>

## 3）面试官追问（Q&A）

问：并发和并行的本质区别是什么？
答：并发是同一 CPU 通过快速切换执行多个任务；并行是多个 CPU 同时执行多个任务。

问：为什么单核 CPU 无法并行？
答：单核同一时刻仅能执行一个指令流，但可通过高速切换模拟并行效果。

问：并发的性能瓶颈在哪里？
答：上下文切换成本高，多任务争抢 CPU，过细时间片会降低效率。

问：并行是否一定比并发快？
答：不一定，取决于任务可拆分度、线程创建成本、数据依赖等。

问：多核系统中仍需要并发吗？
答：需要，因为任务数量通常远大于核数，仍需调度和切换。

问：并发和多线程是什么关系？
答：多线程是并发的一种实现方式；并发模型不限于线程，也可基于协程或事件循环。

问：什么时候应该优先考虑并行？
答：在独立且可拆分的计算密集型任务，如数据处理、图像渲染等。

问：时间片对并发有何影响？
答：时间片越短越丝滑但开销越大；越长切换少但不公平。

## 4）示意图（ASCII）

```
并发 vs 并行

并发（单核轮转）：
┌────── CPU(1) ───────┐
│ A │ B │ A │ C │ B │ C │ ...（快速切换）  
└────────────────────┘

并行（多核同时）：
┌────── CPU1 ───────┐   ┌────── CPU2 ───────┐
│   A   （独占）     │   │   B   （独占）     │
└───────────────────┘   └───────────────────┘
```
