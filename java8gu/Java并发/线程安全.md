## 1）10 行极简速记版（小红书爆款风）

✔ 线程安全 = 多线程抢同一块地却不能踩坑
🔥 安全三要素：原子性、可见性、有序性，少一个都翻车
📌 共享变量才有风险，局部变量天生“无敌”
🚀 JVM：堆/方法区共享，栈独享，线程风险直接看内存分布
⚠️ 写多读少最危险，读多写少次之，只读最安全 
🧠 并发只是“轮流假象”，并行才是真·同时干活
✨ 进程分资源，线程分执行，轻量但更容易踩共享坑
📈 上下文切换越多越乱，线程越多越容易出幺蛾子
🔍 虚拟线程降低 OS 切换成本但不消灭线程安全问题
➤ 变量放哪决定风险在哪，堆区变量慎之又慎

## 2）折叠式知识卡片版

<details>
<summary>定义</summary>

线程安全：多个线程并发访问共享变量时，程序执行结果仍与预期一致，不因交错调度而被破坏。核心取决于原子性、可见性与有序性。

</details>

<details>
<summary>原理</summary>

* 多线程共享堆/方法区数据，调度基于时间片轮转，执行交织易导致状态竞争。
* 进程是资源分配单元，线程是执行单元，同一进程内线程上下文切换轻但仍需保存 TCB 状态。
* 上下文切换导致执行顺序不可控，需依赖同步手段保障操作原子性及可见性。
* 虚拟线程为用户态调度，降低 OS 切换成本，但不改变共享变量竞争本质。

</details>

<details>
<summary>关键点</summary>

* 线程安全问题出现于“共享”+“可写”变量。
* 类变量/实例变量位于方法区和堆，是典型共享变量。
* 局部变量位于栈，每线程独有，默认线程安全。
* 上下文切换是并发问题产生的根源之一。
* JDK21 虚拟线程只优化调度，不优化数据竞争。

</details>

<details>
<summary>扩展知识</summary>

文档未深入同步手段，可合理补充：

* 线程安全常用保障机制：锁、CAS、volatile、有序性屏障等。
* 设计层面减少共享、避免可变对象，可降低风险。

</details>

## 3）面试官追问（Q&A）

问：为什么共享变量会导致线程安全问题？
答：线程对共享变量的读写会被时间片切分，执行顺序不可控，若操作非原子，会出现竞争、覆盖与脏读。

问：哪些变量属于共享变量？
答：类变量与实例变量存于方法区/堆，多线程可同时访问。栈上的局部变量为线程私有，不共享。

问：只读共享变量是否一定安全？
答：是，多线程同时读不会破坏状态。但若对象内部可变，读操作间接触发写则仍不安全。

问：上下文切换为何会影响线程安全？
答：切换导致执行片段被拆分组合，多线程交错时原子操作被破坏。

问：虚拟线程是否解决线程安全？
答：否，虚拟线程仅优化调度，不改变共享内存的竞争模型。

问：如何判断一个变量是否需要加锁？
答：是否共享、是否可写、是否存在复合操作（读-改-写），三者只要满足即可考虑同步。

问：为什么局部变量线程安全？
答：局部变量存于栈，每个线程独立一份，访问不交叉。

问：原子性、可见性、有序性各自对应哪些问题？
答：原子性防止状态撕裂；可见性解决缓存隔离；有序性避免指令重排导致的前后关系错乱。

问：Java 中堆和栈的差异对安全有何影响？
答：堆共享导致竞争风险，栈独占避免冲突。

## 4）示意图（ASCII）

```
多线程并发模型
┌──────────────────────────┐
│           JVM 进程          │
│  ┌──────────────┐        │
│  │   方法区(共享) │◄───类变量 │
│  ├──────────────┤        │
│  │     堆(共享)   │◄───实例变量│
│  └──────────────┘        │
│        ▲      ▲           │
│   线程A  线程B ...         │
│   ┌──────────┐            │
│   │ 各自栈(独享)│─局部变量→安全 │
│   └──────────┘            │
└──────────────────────────┘
       ↑
       共享+可写 → 线程安全风险
```
