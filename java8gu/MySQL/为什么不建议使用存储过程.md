Not_Use_Stored_Procedure
✔ 可维护性极差，逻辑越写越乱
⚠️ 调试困难，无法像代码一样断点
📌 跨数据库不可移植，迁移成本爆炸
🔥 复杂业务写在 SQL 里极易踩坑
🧠 权限与安全界面更模糊
🚀 无法纳入常规版本控制体系
🔍 CodeReview 难覆盖 SQL 分支
➤ 大型系统普遍放弃存储过程
📈 业务逻辑放应用层才能工程化
✨ 现代架构早已弱化其价值

---

## 折叠式知识卡片版

<details>
<summary>① 定义</summary>

* 存储过程（Stored Procedure）是数据库端的预编译 SQL 逻辑单元，可接受参数、执行多条语句，并包含控制流。
* 本质是“把业务逻辑塞进数据库内执行”的做法，用于早期数据库中心化架构。

</details>

<details>
<summary>② 原理</summary>

* 存储过程在数据库内部执行，遵循数据库语法/执行引擎，无法享受现代应用代码的工程化体系（调试、日志、版本控制、CI、测试）。
* 跨数据库适配性极差，不同数据库的过程语言差异大（MySQL、Oracle、PG 互不兼容）。
* 多分支业务逻辑通过 IF/ELSE、SIGNAL 等数据库控制语句组织，容易形成难维护的逻辑丛林。

</details>

<details>
<summary>③ 关键点</summary>

* **可维护性差**：复杂逻辑写 SQL 里会迅速不可读。
* **调试困难**：无法像应用代码一样打印日志、断点、单元测试。
* **迁移成本高**：跨数据库不兼容，迁移必重写。
* **易出错**：多分支业务写在 SQL 中可读性差、错误率高。
* **安全性风险**：输入验证弱、SQL 注入、权限配置复杂。
* **不易版本控制**：过程代码保存在 DB 内部，不在 Git 流程中。
* **审查困难**：SQL 的 CodeReview 往往不如业务代码严格。

</details>

<details>
<summary>④ 扩展知识</summary>

* 大型系统普遍采用“**应用层负责业务逻辑，数据库负责存储与查询**”的分层架构。
* 微服务时代 DB 不再承担业务逻辑，存储过程天然不适配分布式场景。
* 现代数据库（如 PG/Oracle）在过程语言更强，但工程团队仍多将业务逻辑放在应用层（合理补充）。

</details>

---

## 面试官追问（Q&A）

**问：为什么应用层逻辑比存储过程更可控？**
答：应用层具备日志、断点、单测、CI/CD、静态检查等工程体系，存储过程无法享受这些能力。

**问：存储过程为什么难调试？**
答：数据库层缺乏断点和系统化日志，逻辑出错时只能靠输出或排查状态，非常低效。

**问：如果公司要多库迁移，存储过程会造成什么问题？**
答：过程语言不兼容，所有存储过程都必须重写，是迁移成本最大阻力之一。

**问：复杂业务写在存储过程里为什么容易出错？**
答：SQL 的控制流语言弱，可读性差，多分支条件容易变成“意大利面代码”。

**问：存储过程的安全风险体现在哪？**
答：输入校验不严易导致 SQL 注入，权限对象较多，审计和访问控制更复杂。

**问：存储过程能否进行版本管理？**
答：理论上能 dump，但无法自然融入 Git/Review/CI 流程，实际很难做到可审计可追踪。

**问：哪些场景存储过程仍然适合？**
答：高吞吐批处理、DB 内部轻逻辑计算、存算一体场景（但现代系统极少使用）。

---

## 示意图（ASCII）

```
传统使用方式

客户端 → 存储过程调用 → DB 内执行业务逻辑 → 数据结果

现代架构（推荐）

客户端 → 应用服务（业务逻辑、校验、日志） → SQL 操作 → DB 仅做数据存取
```

（完）
