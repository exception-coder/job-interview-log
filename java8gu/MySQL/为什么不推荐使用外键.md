Why_Not_Use_Foreign_Key
✔ 外键强一致性=高开销
⚠️ 高并发下锁竞争明显放大
📌 跨库分片无法保持外键约束
🔥 级联更新/删除易触发更新风暴
🧠 外键检查增加写入路径成本
🚀 应用层维护关系更灵活
🔍 大厂默认禁用外键与级联
➤ 逻辑删除与外键天然冲突
✨ 外键影响插入/删除吞吐

---

## 折叠式知识卡片版

<details>
<summary>① 定义</summary>

* 外键（Foreign Key）保证引用完整性：子表字段必须存在于父表主键中。
* 约束目标：保证数据一致性、防止删除父记录导致“悬空引用”。
* 文档指出：大型互联网应用普遍禁止使用外键，将一致性逻辑放到应用层处理。

</details>

<details>
<summary>② 原理</summary>

* 外键要求数据库在 **INSERT/UPDATE/DELETE** 时做引用检查，涉及额外索引查找。
* 父子表之间可能触发 **级联操作（CASCADE）**，造成数据库内部同步更新。
* 外键依赖单机强一致结构，无法映射到分库分表或分布式存储。
* 外键约束会参与 InnoDB 锁管理，引入额外锁依赖链。

</details>

<details>
<summary>③ 关键点</summary>

* **性能影响**：每次写操作都需要额外检查父表存在性、维护外键索引 → 写放大。
* **锁竞争风险**：并发更新子表必须访问父表 → 增加 MDL/行锁竞争，易引发死锁。
* **分库分表不兼容**：外键无法跨库检查引用关系，分布式环境直接失效。
* **逻辑删除冲突**：业务常用逻辑删除（is_deleted），而外键需物理删除才能保证约束。
* **极端情况触发更新风暴**：级联更新/删除导致大量子记录同步修改。
* **插入速度下降**：外键索引 + 检查 → 对写入吞吐影响显著。

</details>

<details>
<summary>④ 扩展知识</summary>

* 大厂架构遵循原则：**一致性交给应用层**，数据库保持极简，避免强约束影响可扩展性。
* 分布式事务、跨表一致性常用 MQ + 补偿机制、准备表（outbox）等方式处理（文档未提及，此为合理补充）。
* 外键可用于 OLTP 小规模系统，如强一致 ERP/账务类系统，但不适用于高并发互联网流量。

</details>

---

## 面试官追问（Q&A）

**问：为什么外键在高并发场景性能差？**
答：每次写操作需检查父表引用，还需维护额外索引；加上锁竞争，使写路径显著变慢。

**问：外键与分库分表为什么冲突？**
答：外键依赖单库内的数据可见性，而分库后父子记录不在同一库，无法完成引用检查。

**问：级联更新为什么危险？**
答：父表更新可能触发大量子记录同步更新，引发锁风暴甚至雪崩式阻塞。

**问：逻辑删除与外键怎么冲突？**
答：外键要求真实存在/不存在，而逻辑删除仅是标记，不符合外键语义，会导致约束异常。

**问：应用层维护外键关系如何保证一致性？**
答：通过服务层事务、重试机制、幂等设计、补偿逻辑等方式实现。

**问：什么时候可以使用外键？**
答：单库小规模系统、强一致需求、写少读多场景，如传统 ERP/财务类应用。

**问：不用外键会不会出现脏数据？**
答：会，但可通过业务规则、唯一索引、应用层校验减少风险；换取的是扩展性和吞吐。

---

## 示意图（ASCII）

```
外键写操作路径（简化）

INSERT 子表记录
     │
     ├─→ 检查父表主键是否存在（需访问父表索引）
     │
     ├─→ 加锁（行锁/意向锁可能竞争）
     │
     └─→ 插入成功（或触发级联更新/删除）

高并发下：检查 + 锁竞争 → TPS 明显下降
```

（完）
