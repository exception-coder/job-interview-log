### mysql_avoid_select_star

#### 1）10 行极简速记版（纯文本）

✔ SELECT * 会放大 I/O 与网络开销
📌 读取无用字段导致数据传输浪费
🔥 覆盖索引失效 → 必须回表
⚠️ 容易把敏感字段误暴露给前端
📈 表结构变动会引入潜在兼容问题
🧠 字段新增后可能导致应用异常
🔍 精确列选择可提升缓存命中与可读性
✨ 只取必要列是查询优化的核心原则
🚀 更适合使用列投影控制数据库负载
✘ SELECT * 是非常不利于线上高并发的写法

---

#### 2）折叠式知识卡片版

<details>
<summary>定义</summary>

`SELECT *` 会取出表中的所有列，用于快速原型开发或临时查询。但在生产环境中会显著增加数据库负载并引入数据泄露风险，因此广泛被禁止使用。

</details>

<details>
<summary>原理</summary>

* 查询引擎会根据 SELECT 列清单确定是否能使用覆盖索引；使用 `*` 时索引无法覆盖，必须回表取完整行。
* 返回所有字段会增加扫描的列数量、行宽大小，从而增加磁盘 I/O 和网络带宽消耗。
* 表结构变化（新增/删除字段）会导致依赖 `*` 的代码行为不可预测。

</details>

<details>
<summary>关键点</summary>

* SELECT * 导致全列读取，浪费内存与网络传输。
* 破坏覆盖索引策略，使查询必须回表，延迟大幅上升。
* 可能返回敏感字段（密码、标记、内部字段），带来安全隐患。
* 表结构变更可能导致应用序列化/反序列化失败。
* 代码可读性差，不利于 SQL 审阅和安全审查。

</details>

<details>
<summary>扩展知识</summary>

* 数据库曾依赖 Query Cache，SELECT * 会导致缓存雪崩（8.0 已移除）。
* 覆盖索引（index only scan）是高性能查询的关键点，而 `*` 会破坏这一能力。
* 在 API 层只返回必要字段可大幅降低序列化/反序列化开销。
* 表宽越大，`SELECT *` 性能越差（典型如 JSON、TEXT、BLOB 的大列）。

</details>

---

#### 3）面试官追问（Q&A）

**问：为什么 SELECT * 会导致覆盖索引失效？**
答：覆盖索引要求查询字段全部在索引中，而 `*` 强制查询所有列，必然需要回表访问数据页。

**问：SELECT * 对性能的影响体现在哪里？**
答：行宽越大，扫描与网络传输越重；对于大表会成倍增加磁盘 I/O。

**问：为什么 SELECT * 存在安全风险？**
答：新增敏感字段（如 internal_flag、password_hash）时，`*` 会自动暴露这些字段给调用方。

**问：何时可以用 SELECT *？**
答：临时排障、开发环境、离线脚本，但禁止在生产接口和高 QPS 查询中使用。

**问：表字段变更为什么会导致应用异常？**
答：ORM 映射依赖字段集合，新增字段可能导致序列化异常或数据结构不匹配。

**问：SELECT * 真的会影响缓存吗？**
答：旧版本 MySQL Query Cache 依赖 SQL 字符串一致性，字段变更会导致缓存失效（8.0 已移除）。**

---

#### 4）示意图（ASCII）

```
SELECT * 执行路径

   索引访问 → 定位行指针
                ↓
            回表取整行   ← 不能覆盖索引
                ↓
           返回所有列     ← 无用列也被取出
```

```
精确列投影（推荐）

SELECT id, name
    ↓
覆盖索引直接返回，无需回表
```

如需，我可以继续补充《覆盖索引优化指南》《线上 SELECT * 风险案例》。
