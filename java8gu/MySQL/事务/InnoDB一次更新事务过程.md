## 1）10 行极简速记版（小红书爆款风）

✔ SQL 执行链路 = 连接 → 解析 → 优化 → 执行 → 返回
🔥 查询缓存（8.0已移除）命中 = 直接跳过所有流程
📌 解析器决定“你写的 SQL 到底想干嘛”
🚀 优化器才是灵魂，决定“怎么干更快”
🧠 执行器联动存储引擎，最终读写真实数据
✨ 权限校验在最前，没权限直接拜拜
📈 执行计划基于索引选择路径，选错就性能灾难
🔍 不同引擎（InnoDB/MyISAM）执行方式完全不同
⚠️ 语法合法不代表能跑，预处理器还会检查表和字段
➤ 整条链路本质：解析树 → 执行计划 → 引擎执行

## 2）折叠式知识卡片版

<details>
<summary>定义</summary>

SQL 执行过程：客户端发送 SQL，经连接器验证权限，进入解析器生成解析树，预处理器检查语义合法性，优化器生成执行计划，执行器调用存储引擎完成读取或写入，最终返回结果。

</details>

<details>
<summary>原理</summary>

* **连接器**：完成用户认证与权限校验，建立会话。
* **查询缓存（8.0 前）**：完全相同的 SQL 若命中缓存直接返回。
* **解析器**：词法+语法分析，生成解析树；预处理器检查表名字段合法性。
* **优化器**：根据统计信息与索引生成最优执行计划。
* **执行器**：按计划调用存储引擎 API，执行查询或更新。
* **存储引擎**：InnoDB/MyISAM等，负责真正的数据读写。

</details>

<details>
<summary>关键点</summary>

* SQL 的性能核心取决于优化器的执行计划质量。
* 解析阶段只做结构理解，不做性能优化。
* 查询缓存严格依赖“完全相同 SQL 文本”。
* 存储引擎差异导致最终执行路径完全不同。
* 执行器与引擎解耦，使 MySQL 可支持多种引擎。

</details>

<details>
<summary>扩展知识</summary>

文档未提但可合理补充：

* MySQL8.0 移除 Query Cache，因为高并发下缓存锁争用成本过高。
* 执行计划可通过 `EXPLAIN` 观察，用于分析是否走索引。

</details>

## 3）面试官追问（Q&A）

问：解析器和预处理器的区别是什么？
答：解析器负责语法结构分析，预处理器负责语义校验，如表/列是否存在、权限是否满足。

问：优化器如何选择最优执行计划？
答：基于代价模型（cost model），根据索引、行数统计、比较语句生成最低成本方案。

问：为什么查询缓存逐渐被废弃？
答：并发场景下缓存失效频繁，维护成本高，锁竞争严重，反而降低性能。

问：执行器如何与存储引擎解耦？
答：通过统一的存储引擎 API，使得不同引擎（InnoDB/MyISAM）按同一接口提供服务。

问：SQL 为什么可能执行得非常慢？
答：索引未命中、执行计划不佳、统计信息陈旧、存储引擎瓶颈、锁等待等。

问：执行计划什么时候会重新生成？
答：统计信息更新、表结构变化、大量数据改变等都会触发新计划。

问：语法正确但为什么执行时报错？
答：预处理器发现列不存在、表不存在、权限不足等语义问题。

问：连接器的权限检查何时执行？
答：连接阶段及 SQL 执行前都会做权限验证。

## 4）示意图（ASCII）

```
SQL 执行全链路

客户端
   │ 发送SQL
   ▼
连接器 → 权限校验
   ▼
(8.0前) 查询缓存命中？───是→ 返回
   │否
   ▼
解析器 → 解析树 → 预处理器检查
   ▼
优化器 → 执行计划
   ▼
执行器
   ▼ 调用
存储引擎(InnoDB/MyISAM)
   ▼
返回结果
```
