10 行极简速记版（纯文本）
✔ RR 解决“部分幻读”，并非彻底杜绝
🔥 快照读靠 MVCC，不会读到新插入行
🚀 当前读靠间隙锁，阻止插入避免幻读
⚠️ 没来得及加锁就读 → 间隙锁失效 → 仍会幻读
📌 RR 下 UPDATE 属于当前读，会看到新插入的记录
🔍 同事务混用快照读 + 当前读 → 极易出现幻读
🧠 MVCC 只对快照读有效，对当前读无能为力
✨ 想百分百消灭幻读 → 只能用 Serializable
📈 RR 要避免幻读：事务开始就加锁
🚨 间隙锁可控幻读，但会显著增加死锁风险

---

折叠式知识卡片版

<details>
<summary>定义</summary>

文档讨论 InnoDB 在 **REPEATABLE READ（RR）** 隔离级别下是否真正解决幻读。核心观点：

* RR 能通过 **MVCC + 间隙锁** 解决大部分常见幻读场景；
* 但在“混用快照读与当前读”“未及时加锁”等场景，幻读仍然能发生；
* 想彻底消灭幻读需使用 **Serializable**。

</details>

<details>
<summary>原理</summary>

1. **快照读（MVCC）**：

    * RR 中快照在第一次 SELECT 时生成并固定；
    * 之后的快照读均读取快照版本，不会看到其他事务插入行 → 不发生幻读。

2. **当前读（锁）**：

    * SELECT … FOR UPDATE / UPDATE / DELETE 需读取最新版本；
    * InnoDB 在 RR 下加入 **间隙锁**（Gap Lock）锁住记录间隙，阻止插入避免幻读。

3. **不能避免的情况**：

    * 当前读发生在插入之后才加锁 → 间隙未锁住 → 新行可见 → 发生幻读；
    * 同一事务先快照读，再当前读 → 版本切换导致幻读；
    * UPDATE 作为当前读能读到他人新提交的数据 → 典型幻读。

</details>

<details>
<summary>关键点</summary>

* **MVCC 只解决快照读的幻读**，不解决当前读的幻读。
* **间隙锁（Gap Lock）** 阻塞插入，避免当前读幻读，但需在事务开始及时上锁。
* **RR ≠ 无幻读**，只是“减少幻读”而非“杜绝幻读”。
* **混合读模式（快照 + 当前）** 会让可见性发生跳跃，是幻读高发点。
* **Serializable** 通过强加锁覆盖所有读写场景，能彻底避免幻读但并发能力最差。

</details>

<details>
<summary>扩展知识</summary>

* Gap Lock / Next-Key Lock 可视为索引区间的逻辑保护，防止插入造成可见性差异。
* UPDATE 属于当前读，因此能观察到最新提交版本，不受快照束缚。
* RR 中“本事务更新会刷新快照”导致后续快照读结果变化，这是内部设计逻辑（文中案例已体现）。

</details>

---

面试官追问（Q&A）

**问：为什么 RR 不能彻底解决幻读？**
答：RR 依赖 MVCC（快照读）和间隙锁（当前读）。但锁的生效时机有限，如果读发生在加锁之前或是快照读与当前读混用，仍会暴露新插入记录，从而出现幻读。

**问：MVCC 能解决哪些幻读？**
答：MVCC 仅解决快照读场景的幻读，即事务内多次 SELECT 读到一份一致性视图，不受其他事务插入影响。

**问：为什么当前读需要间隙锁？**
答：当前读要读最新数据，如果不对区间加锁，其他事务可插入新记录导致当前读结果发生偏移，因此需要 Gap Lock 阻止插入。

**问：UPDATE 为什么会产生幻读？**
答：UPDATE 是当前读，会读取新提交的行。如果另一事务在前一个快照读之后插入了记录，UPDATE 会看到它，从而产生幻读。

**问：为什么在事务开始就加锁可以减少幻读？**
答：提前加锁能让间隙锁覆盖整个读写区间，阻断并发插入，避免后续当前读看到新行。

**问：Gap Lock 为什么易引起死锁？**
答：Gap Lock 锁的是区间而非单行。在高并发下不同事务可能锁住互相重叠的区间，形成环依赖，触发死锁检测。

**问：RR 与 Serializable 的本质差异？**
答：RR 通过 MVCC+行级锁/间隙锁实现“读一致”，但允许一定程度的并发；Serializable 强制所有读也上锁，彻底禁止并发写入导致的幻读，但性能最差。

**问：为什么同一事务中快照读 + 当前读会引发幻读？**
答：快照读固定了版本视图，而当前读访问最新版本，两者结合会形成版本跳跃，使新插入行暴露出来。

---

示意图（ASCII）

```
      RR 下的快照读
┌───────────────────┐
│ Tx1: SELECT ...    │ → 生成快照视图 V1
└───────────────────┘
      ↓ 再次 SELECT
      仍读取 V1，不会看到 Tx2 插入的新行
```

```
      RR 下的当前读（间隙锁）
索引区间: (10, 20)

Tx1: SELECT ... FOR UPDATE
 → 锁住区间 (10,20)

Tx2: INSERT ... VALUES(15)
 → 被阻塞，避免幻读
```

```
      不能避免的幻读
Tx1: SELECT ... (快照读，得到 V1)
Tx2: INSERT 新行并提交
Tx1: UPDATE ...（当前读）
 → 看到新行 → 发生幻读
```

（总结完毕）
