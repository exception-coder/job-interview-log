## 1）10 行极简速记版（小红书爆款风）

✔ 脏读 = 读到了别人“还没提交”的临时数据
🔥 不可重复读 = 前后两次读同一行，结果竟然不同
📌 幻读 = 范围查询返回的行数突然多了/少了
🚀 脏读来源：读到未提交事务的修改
🧠 不可重复读来源：别的事务修改了已读数据
✨ 幻读来源：别的事务插入/删除了范围内的记录
📈 解决幻读靠“范围锁 Range Lock”
🔍 三者本质差别：读未提交 vs 读已提交后变化 vs 读范围后变化
⚠️ 可重复读并不一定完全解决幻读（需看锁）
➤ 三类读异常 = 事务隔离级别设计的核心矛盾点

## 2）折叠式知识卡片版

<details>
<summary>定义</summary>

* **脏读（Dirty Read）**：读到了其他事务未提交的数据。
* **不可重复读（Non-repeatable Read）**：同一个事务中多次读同一行数据，结果不同，因为其他事务修改/删除了该行。
* **幻读（Phantom Read）**：同一事务范围查询两次，第二次返回的行数变了，因为其他事务插入/删除了新记录。

</details>

<details>
<summary>原理</summary>

* 脏读：事务未提交的数据被其他事务读取。
* 不可重复读：别的事务对已读取的记录进行了 UPDATE/DELETE。
* 幻读：别的事务对查询范围进行了 INSERT/DELETE。
* 幻读的根因是“范围变化”，仅靠行锁无法避免，因此需要 **范围锁（RangeS/RangeX）**。

</details>

<details>
<summary>关键点</summary>

* 幻读是不可重复读的特殊形式（针对范围查询）。
* 避免脏读 → 最低需要 RC。
* 避免不可重复读 → 需要 RR。
* 避免幻读 → 需要 Serializable 或 InnoDB 的间隙锁/范围锁。
* InnoDB 的 RR 利用 MVCC 避免大部分幻读，但“当前读”仍可能出现幻读（需锁参与）。

</details>

<details>
<summary>扩展知识</summary>

文档未写但可补充：

* 幻读与 GAP Lock、Next-Key Lock 机制高度相关。
* MVCC 只解决“快照读”的幻读，无法解决当前读的幻读。
* 事务隔离级别决定了三种读异常的可见性。

</details>

## 3）面试官追问（Q&A）

问：幻读与不可重复读的根本区别是什么？
答：不可重复读影响的是“行内容变化”；幻读影响的是“行数量变化”（范围内的记录新增/删除）。

问：脏读为什么危险？
答：它允许读取未提交数据，若写事务回滚，读事务就基于无效数据做决策。

问：RR 是否解决了幻读？
答：InnoDB 的 **快照读** 解决；**当前读** 不解决，需要范围锁（Next-Key Lock）。

问：幻读为什么一定需要范围锁？
答：因为锁的对象是“范围”，不是单行，否则 INSERT 会穿透锁引发幻读。

问：不可重复读与 MVCC 的关系？
答：MVCC 通过版本链让快照读永远得到一致版本，从而避免不可重复读。

问：Serializable 如何彻底解决幻读？
答：强制所有 SELECT 都加锁，令并发度降至最低，从根本避免插入/删除。

问：脏读属于哪种隔离级别才会发生？
答：Read Uncommitted（RU）。

问：幻读发生在哪种场景最典型？
答：`SELECT ... WHERE 条件` 的范围扫描 + 其他事务 INSERT 符合条件的新记录。

## 4）示意图（ASCII）

```
三大读异常关系图

脏读（Dirty Read）
T1: UPDATE x=100（未提交）
T2: SELECT x → 读到 100（脏）

不可重复读（Non-repeatable Read）
T1: SELECT x → 10
T2: UPDATE x=20 COMMIT
T1: SELECT x → 20（变了）

幻读（Phantom Read）
T1: SELECT * FROM users WHERE age > 18 → 返回3行
T2: INSERT 新记录 age=20
T1: SELECT * FROM users WHERE age > 18 → 返回4行（多了）
```
