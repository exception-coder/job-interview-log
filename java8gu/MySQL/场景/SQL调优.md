总结标题：mysql_sql_tuning

---

## 1）10 行极简速记版（纯文本）

✔ SQL 慢 = 找 SQL + 查执行计划
🔥 慢 SQL 90% 来自索引问题或多表 join
📌 explain 的 type/key/extra 是调优核心
🧠 单表过大、区分度差、深分页都会拖慢查询
➤ select *、长事务、锁竞争是隐性杀手
🚀 表大就分表/归档，join 重就冗余字段
✨ 缓存、连接池、参数优化也影响 SQL 性能
📈 场景大就用分布式库或搜索引擎（TiDB/ES）
⚠️ 调优是系统性工程，不能只盯 SQL 本身

---

## 2）折叠式知识卡片版（Markdown）

<details>
<summary>定义</summary>

SQL 调优是定位并优化造成查询变慢的 SQL 语句，提升整体 RT、吞吐与并发能力的系统化过程。调优内容涵盖 SQL 本身、索引、表结构、锁、事务、参数、硬件等多个维度。

</details>

<details>
<summary>原理</summary>

SQL 性能决定于以下几个核心因素：

* 索引是否可用、是否被正确选中（CBO 成本模型决定路径）
* 扫描行数是否可控
* 回表次数是否过多
* join 复杂度是否可接受
* 是否锁阻塞或等待
* 事务、连接、资源（CPU/IO/内存）是否饱和

调优过程遵循：
1）找慢 SQL → 2）explain 分析 → 3）定位瓶颈 → 4）按原因优化 → 5）回归验证。

</details>

<details>
<summary>关键点</summary>

**一、典型 SQL 变慢原因：**

* 索引失效（最常见）
* 多表 join 过多 → Nested Loop 放大扫描
* 表中数据量过大、无归档
* 查询字段太多（select *）
* 索引区分度不高
* 深分页 (`limit 100000,20`)
* 长事务占用连接
* 锁竞争（行锁、间隙锁）
* 数据库资源不足（CPU/IO/连接池）
* 表结构不合理：字段过大、多表依赖过重
* 数据库参数不合理（buffer_pool/log_file/threads）

**二、主要调优思路：**

1）**索引相关优化**

* 修复索引失效（函数/计算/类型转换/模糊查询）
* 改写 SQL 以满足最左前缀
* 使用覆盖索引减少回表
* 使用 force index 验证索引路径
* 提升区分度 or 重建更优索引结构

2）**JOIN 优化**

* 尽量减少多表 join，降低嵌套循环代价
* 冗余字段/逆范式结构减少 join 次数
* 让小表驱动大表（优化器有时会判断错误）

3）**数据量优化**

* 分库分表、分区
* 冷数据归档
* 将海量历史查询迁移至 ES/TiDB/OceanBase

4）**查询语句优化**

* 避免 select *
* 避免深分页：使用 id > last_id 方式

5）**连接池/事务/锁优化**

* 减少事务范围和时间
* 解决慢 SQL 以避免连接耗尽
* 锁竞争根据死锁日志与等待链定位

6）**DB 实例层调优**

* CPU/IO 高时需排查慢 SQL、热点表、频繁全表扫描
* 增加 buffer_pool、优化日志文件大小、I/O threads

7）**架构层优化**

* 读写分离
* 本地与集中缓存
* 降低数据库直接查询吞吐

</details>

<details>
<summary>扩展知识</summary>

**参数优化要点：**

* `innodb_buffer_pool_size`: 占用 70–80% 内存
* `innodb_log_file_size`: 1GB 或高峰两小时写入量
* `innodb_read_io_threads` / `innodb_write_io_threads`: CPU 核数一半
* 统计信息通过 `ANALYZE TABLE` 保持最新
* 大事务应拆分避免 undo 增长与锁持久化

其他大规模优化手段：

* 使用存储引擎优化（如将查询类业务迁移到 TiDB/ES）
* 使用数据中台或 CDC 同步降低主库压力
* 对热点 key 做缓存与拆分

</details>

---

## 3）面试官追问（Q&A）

**问：SQL 调优的第一步是什么？**
答：找到具体慢 SQL，并通过 explain 查看执行计划。

**问：为什么不建议多表 join？**
答：Nested loop 放大扫描次数，驱动顺序不佳会导致指数级放大。

**问：索引区分度低一定不能建索引吗？**
答：不一定，看扫描成本；区分度低但访问频繁仍可有效。

**问：深分页为什么慢？如何优化？**
答：offset+n 会扫描 offset 行并丢弃，使用“上次 ID + limit”优于 offset 方式。

**问：如何快速判断 SQL 是否走索引？**
答：explain 中 key 是否为 NULL、type 是否 ≥ range、extra 是否包含 using index。

**问：什么情况下需要考虑分库分表？**
答：单表过千万、QPS 过高、连接数耗尽、大躺平存储导致性能恶化。

**问：select * 为什么危险？**
答：额外回表、增加网络传输、破坏覆盖索引、增加执行成本。

**问：IO/CPU 高一定是数据库问题吗？**
答：不一定，通常是业务 SQL 设计导致的集中热点或死锁阻塞。

**问：如何让 join 更快？**
答：小表驱动大表、优先使用可覆盖索引、减少 join 次数或做字段冗余。

---

## 4）示意图（ASCII）

```
SQL 调优流程图

        +--------------------+
        | 发现慢 SQL：监控/报警 |
        +---------+----------+
                  |
                  v
        +--------------------+
        |  EXPLAIN 分析执行计划  |
        | type/key/extra      |
        +---------+----------+
                  |
                  v
      +-------------------------+
      | 判定瓶颈：索引/IO/锁/join |
      +------------+------------+
                   |
         +---------+---------+
         |                   |
         v                   v
+----------------+   +-----------------+
| SQL/索引优化   |   |  DB 实例/架构优化 |
+----------------+   +-----------------+
                   |
                   v
        +---------------------+
        | 回归测试 + 性能验证  |
        +---------------------+
```

---
