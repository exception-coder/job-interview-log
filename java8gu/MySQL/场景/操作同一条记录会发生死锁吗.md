总结标题：mysql_deadlock_same_record

---

## 1）10 行极简速记版（纯文本）

✔ 同一条记录也可能死锁
⚠️ 因为锁的是“索引”，不是“记录”
📌 普通索引 → 回表 → 主键索引，多阶段加锁
🔥 两个事务加锁顺序不一致最容易死锁
➤ update/where 命中不同索引顺序会冲突
🧠 name → id 与 id → name 两种路径互相等待
✨ 保证统一的索引加锁顺序可避免死锁
🔍 强制按主键索引→二级索引顺序访问
📈 设计 SQL 时避免条件导致不同锁路径
🚀 核心原则：锁顺序一致，避免交叉依赖

---

## 2）折叠式知识卡片版（Markdown）

<details>
<summary>定义</summary>

即使多个事务只操作同一行数据，MySQL 仍然可能产生死锁。
原因在于 InnoDB 加锁对象是 **索引项**，而非“某一行”。
不同 SQL 使用不同索引路径，会造成加锁顺序相反，从而形成死锁循环依赖。

</details>

<details>
<summary>原理</summary>

InnoDB 更新记录需要锁定：

* 条件命中的 **二级索引项**（普通索引）
* 然后回表锁 **主键索引项**

过程示例：

```
UPDATE ... WHERE name='xxx'
→ 锁 name 索引项 → 回表锁 id 索引项
```

另一种路径：

```
SELECT ... WHERE id=xxx FOR UPDATE
→ 先锁 id 索引项 → 再锁 name 索引项
```

若两个事务走相反顺序：

```
T1: name → id
T2: id → name
```

→ 形成环路等待 → 死锁。

</details>

<details>
<summary>关键点</summary>

* InnoDB 的锁粒度是“索引项”
* 更新走二级索引一定会“先二级→再主键”
* 使用主键查询 for update 会“先主键→再二级”
* 两种不同访问路径的锁序不同 → 冲突发生
* 死锁往往发生在普通索引与主键索引交叉加锁
* 强制统一锁顺序可避免此类死锁

</details>

<details>
<summary>扩展知识</summary>

* 避免使用含模糊条件的普通索引更新，如 `name LIKE 'xx%'`
* 可通过 **覆盖索引** 避免回表，从而减少锁的层级
* 使用 `FORCE INDEX` 约束访问路径
* 系统内可统一：**先按主键访问，再按二级索引访问**
* 死锁不可避免，但必须可控：检测并自动重试是工程常见策略

</details>

---

## 3）面试官追问（Q&A）

**问：为什么“只更新一条记录”还会死锁？**
答：因为索引加锁顺序不同导致互相等待，不是因为记录数量。

**问：普通索引更新为什么需要回表？**
答：二级索引叶子节点只有主键值，需要回表获取完整行。

**问：如何避免这种死锁？**
答：统一锁顺序（主键 → 普通索引）、使用覆盖索引或调整 SQL。

**问：不用普通索引 update 会死锁吗？**
答：风险更低，但只要存在不同路径的锁序差异仍可能产生。

**问：LIKE 条件为什么更容易导致死锁？**
答：走普通索引范围扫描，锁定范围更大，冲突更容易出现。

**问：是否所有死锁都是坏事？**
答：不是。死锁本身是并发冲突的检测机制，只要自动重试即可。

**问：如何快速判断是索引锁序导致的死锁？**
答：多出现在二级索引与主键之间锁互等，死锁日志中会显示两个事务分别持有不同索引锁。**

**问：是否可以通过禁用某个索引避免死锁？**
答：可以，但通常代价大，应优先调整 SQL 或 FORCE INDEX。**

**问：死锁和锁等待的区别？**
答：锁等待最终可能会成功；死锁是循环依赖，必须回滚其中一个事务。**

---

## 4）示意图（ASCII）

```
死锁产生路径（同一条记录）

             普通索引 name                 主键索引 id
             +-----------+                 +-------------+

T1 更新:
   lock(name)  ----->  lock(id)
                     ^
                     |
                     |
T2 查询/更新:
   lock(id)   <-----  lock(name)

双方各持一把锁，等待另一方 → 循环依赖 → DEADLOCK
```

---
