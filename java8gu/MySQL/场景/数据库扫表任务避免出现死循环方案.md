总结标题：mysql_scan_task_deadloop

---

## 1）10 行极简速记版（纯文本）

🔥 LIMIT 扫描固定前 N 行，失败记录会永远卡住队列
✔ INIT 状态若无法更新，会被反复扫到 → 死循环
⚠️ FAILED/INIT 扫描更危险，会无限重试同一批
📌 根因：扫描没有“游标推进”，无法跳过坏数据
🚀 解决：按 id > lastMaxId 递增扫描，逐批前进
🧠 失败记录应隔离到补偿逻辑，不阻塞主流程
🔍 不要假设扫描任务一定成功推进状态
✨ 批处理任务必须幂等 + 可跳过坏记录
📈 分布式事务失败率高时问题更突出
✘ 只用 LIMIT 不用游标，是扫表任务最大陷阱

---

## 2）折叠式知识卡片版（Markdown）

<details>
<summary>定义</summary>

在数据库按状态扫描任务（如 INIT → SUCCESS/FAILED）的定时任务中，如果使用 `ORDER BY id LIMIT N` 方式固定读取前 N 条数据，当这些记录因业务失败无法推进状态时，会被持续重复扫描，导致整个任务处理陷入死循环，后续任务永远无法执行。

</details>

<details>
<summary>原理</summary>

* 使用 `ORDER BY id LIMIT 200` 的查询方式默认假设每条扫描记录都会被成功消费并更新状态。
* 若某些 INIT 记录因业务失败、外部调用失败、分布式事务失败等原因无法更新状态，它们会始终排在前 200 条内，被无限重复处理。
* 当失败记录数量达到 LIMIT 上限时，扫描区间完全被“坏记录”占满，后续正常记录永远无法被处理。
* 将 FAILED 也加入扫描条件（`state in (INIT, FAILED)`）会进一步放大问题：失败记录永久阻塞扫描窗口。

</details>

<details>
<summary>关键点</summary>

* 扫描必须可推进，而固定 LIMIT 不具备推进能力。
* 症结是未维护“扫描游标”（cursor），无法跳过问题数据。
* 失败记录应交给补偿队列或重试机制，不应阻塞主扫描流程。
* 正确方案：使用 `id > lastMaxId` + ORDER BY + LIMIT，让扫描区间不断向后推进。
* 主键自增是天然游标，按 id 增序扫描可避免重复处理。
* 批处理任务必须幂等，以支持重复执行但不重复影响。

</details>

<details>
<summary>扩展知识</summary>

* 游标扫描（cursor scan）是大规模批处理的标准手法。
* 对于错误记录应采用“隔离 + 重试”机制，如死信队列、延迟队列或专门的 FAILED 重试表。
* 大事务、多次失败、高外部依赖的任务更易触发死循环。
* 可以结合分页游标与时间维度（例如 `update_time`）进行双重推进。
* MySQL 分页 OFFSET 大性能差，应更倾向于基于主键递增的 cursor 分页。

</details>

---

## 3）面试官追问（Q&A）

**问：为什么 LIMIT 会导致扫表死循环？**
答：LIMIT 固定扫描窗口，无法跳过不能成功处理的记录；这些 INIT/FAILED 记录占住前 N 行后，后续记录永远得不到处理。

**问：为什么 `state in (INIT, FAILED)` 更危险？**
答：FAILED 会永久保留在扫描窗口中，占满 LIMIT 区间，使任务进度锁死。

**问：如何根治这个问题？**
答：引入扫描游标，如 `id > lastMaxId`，每次扫描从上次最大 ID 向后推进。

**问：为什么用主键当作扫描游标？**
答：主键单调递增、唯一且无需额外索引，按主键递增扫描性能最高、最简单。

**问：如何处理扫描失败的数据？**
答：应放入重试队列、异常表、重试线程等补偿机制，不应影响主扫描链路。

**问：扫描游标需要落盘吗？**
答：需要，将 lastMaxId 保存在任务执行记录/表中，支持断点续扫。

**问：使用 OFFSET 分页是否可行？**
答：不推荐，OFFSET 成本高且仍可能因失败记录导致重复扫描大量数据。

---

## 4）示意图（ASCII）

```
错误示例（死循环）：
┌───────────────┐
│ id: 1~200 INIT │ ← 永远失败，状态不更新
└───────────────┘
每次执行：
SELECT ... WHERE state='INIT'
ORDER BY id LIMIT 200
→ 永远拿到同一批，任务锁死

正确示例（游标扫描）：
lastMaxId = 0
loop:
  SELECT ... WHERE state='INIT' AND id > lastMaxId
  ORDER BY id LIMIT 200
  lastMaxId = 本次批次最大 id
→ 批次不断前进，不会卡住
```
