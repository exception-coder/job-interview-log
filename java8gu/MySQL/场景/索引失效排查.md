总结标题：mysql_index_invalid_diagnosis

---

## 1）10 行极简速记版（纯文本）

✔ 索引失效排查从 explain 开始
🔥 type+key+extra 三件套必须重点看
📌 key=NULL 基本就没走索引
🚀 函数、计算、隐式转换最容易导致失效
➤ OR、LIKE 前缀通配、is not null 都可能全表扫
⚠️ 区分度太低 = 优化器主动放弃索引
🧠 表太小也可能不走索引（成本更低）
✨ 不满足最左前缀 = 直接索引失效
🔍 !=、in 列表过大、排序等情况也可能弃用索引
📈 逐条确认 → 调整 SQL / 索引结构 / 类型一致性

---

## 2）折叠式知识卡片版（Markdown）

<details>
<summary>定义</summary>

索引失效是指 MySQL 在执行查询时未选择可用索引，导致全表扫描或索引树全扫描，从而影响查询性能。是否走索引由优化器根据成本模型动态决定。

</details>

<details>
<summary>原理</summary>

判断是否使用索引依赖以下因素：

* 索引匹配度（是否满足最左前缀）
* 索引区分度（选择性）
* 查询条件是否破坏可索引性（计算、函数、类型转换）
* 表数据大小（小表扫全表更快）
* 基于成本的优化器（CBO）估算扫描代价后做选择

执行计划核心字段：

* **key**：实际使用的索引，没有就是 NULL
* **type**：访问类型，期望为 ref/eq_ref/range
* **extra**：关键判断，Using index / Using index condition / Using where / Using filesort 等

</details>

<details>
<summary>关键点</summary>

常见导致索引失效的原因：

* **索引列参与计算**：`a+1=10` → 失效
* **索引列使用函数**：`LEFT(a,3)`、`DATE(a)` → 失效
* **OR 条件**：混合范围条件 OR 会失效；两边都是 = 且都有索引可生效
* **LIKE 非前缀匹配**：`%xx`、`%xx%` → 全表扫描
* **隐式类型转换**：字符串列用数字比较 → 失效
* **不等于 (!= / <>)**：大概率不走索引，但根据数据分布可能例外
* **IS NOT NULL**：通常不走索引，IS NULL 可走
* **ORDER BY 不利用索引**：排序字段未与 WHERE 走同一索引路径 → filesort
* **IN 列表过大**：值太多时优化器认为走索引成本高
* **索引区分度不足**：索引选择性太差（如性别字段）

排查方法：

1. explain 核查 type/key/extra
2. 校验 SQL 是否满足索引结构与最左前缀
3. 检查是否存在计算、函数、隐式转换
4. 分析索引选择性（COUNT(DISTINCT col)/COUNT(*)）
5. 强制 hint（如 FORCE INDEX）验证索引路径是否更优

</details>

<details>
<summary>扩展知识</summary>

* 覆盖索引能避免回表，提高走索引概率
* 索引下推（ICP）能减少回表，但必须满足过滤条件在二级索引上
* 优化器错误估算可能导致走错索引，可通过 `ANALYZE TABLE` 更新统计信息
* 字段类型设计必须统一（如 int ↔ varchar 否则触发隐式转换）
* 复杂 OR 可以拆为 UNION ALL 再合并提升走索引概率

</details>

---

## 3）面试官追问（Q&A）

**问：如何快速判断一条 SQL 是否走了索引？**
答：看 explain → key 是否为 NULL、type 是否为 ref/eq_ref/range、extra 是否含 using index。

**问：为什么 LIKE '%abc' 一定不能走索引？**
答：前缀不确定，无法按 B+Tree 前缀范围定位，只能全扫描。

**问：索引列使用函数为什么会失效？**
答：索引基于原始值排序，函数作用后无法利用排序特性定位。

**问：OR 为什么会让索引失效？**
答：优化器需要确保两侧都能通过索引过滤，否则回退到全表扫描。

**问：!= 是否一定导致索引失效？**
答：不一定，小范围或离散度高时仍可能使用索引。

**问：隐式类型转换会怎么破坏索引？**
答：会导致数据在比较前转型，优化器无法利用原索引值排序结构。

**问：过滤条件越多越好吗？**
答：不一定，错误的范围条件可能扩大索引扫描范围，影响选择。

**问：in 为什么有时走索引，有时不走？**
答：取决于 in 列表大小与索引离散度，优化器按成本决定路径。

---

## 4）示意图（ASCII）

```
索引失效典型场景示意

          SQL 条件
                ↓
   +-------------------------+
   | 是否落在索引最左前缀？  |—— 否 → 全表扫描
   +-------------------------+
                ↓是
   +-------------------------+
   | 是否包含函数/计算？     |—— 是 → 失效
   +-------------------------+
                ↓否
   +-------------------------+
   | 类型是否一致？          |—— 否 → 隐式转换、失效
   +-------------------------+
                ↓是
   +-------------------------+
   | 区分度是否足够？        |—— 否 → 优化器放弃
   +-------------------------+
                ↓是
            可走索引
```

---
