mysql_unique_index_guarantee

✔ 唯一性由 B+Tree 查重 + 加锁校验共同保证
🚀 插入/更新前必须先在唯一索引树上查是否存在
📌 冲突即报错，不允许写入重复键
🧠 InnoDB 用事务 + 行锁阻塞并发写入同键
⚠️ 多事务并发写相同键会排队等待
🔥 NULL 在唯一索引中可出现多次（互不相等）
🔍 唯一索引查询可提前停止，定位更快
📈 更新唯一键需删除旧值再写入新值
➤ 唯一性检查发生在真正落盘前
✔ 插入性能比普通索引稍慢

---

## 2）折叠式知识卡片版

<details>
<summary>定义</summary>

* **唯一索引（Unique Index）**：保证索引列值在表中唯一，插入或更新重复键会失败。
* 依赖 **B+Tree 查找 + 事务锁** 共同实现唯一性约束。

</details>

<details>
<summary>原理</summary>

1. **插入/更新前检查**：
   InnoDB 会先在唯一索引的 B+Tree 中查目标键是否已存在。

2. **加锁避免并发冲突**：

    * 查找过程中对相关索引记录加 **排他锁（X）或 next-key 锁**。
    * 若其他事务同时尝试写相同键，会因锁冲突被阻塞。

3. **事务隔离保障唯一性**：

    * 一个事务持有唯一键的锁后，其他事务必须等待其提交/回滚。

4. **写前一致性检查**：

    * 即使记录还未落盘（redo/undo 还在内存），InnoDB 也会先做唯一性判断。

5. **失败处理**：重复键会返回错误，如 `Duplicate entry 'x' for key 'uk_xxx'`。

</details>

<details>
<summary>关键点</summary>

* 唯一索引插入慢于普通索引，因为多了查重与锁机制。
* 唯一键更新等同于“删旧 + 插新”，涉及两次索引维护。
* 唯一索引可以有多个 **NULL**，因 SQL 标准认为 NULL ≠ NULL。
* 查询唯一索引更快，因为匹配后立即停止，无需继续扫描。
* 并发写同一唯一键时只有一个事务能成功，其余必然冲突或阻塞。

</details>

<details>
<summary>扩展知识</summary>

* 唯一索引控制的是“索引值”，不是“行”；但 B+Tree 会将主键指针作为叶子值。
* 唯一索引在高并发下容易放大锁竞争，热点唯一键更新会造成严重性能瓶颈。
* 可通过业务层分片、hash 前缀、随机键打散热点。
* InnoDB 内部实现还依赖 undo 版本链确保 MVCC 可见性不会破坏唯一性检查。

</details>

---

## 3）面试官追问（Q&A）

**问：唯一性检查是在加锁前还是加锁后？**
答：加锁后进行。必须锁住目标键位，避免并发事务在检查后立即写入导致冲突。

**问：为什么唯一索引允许多个 NULL？**
答：SQL 语义认为 NULL 是“未知”，每个 NULL 都不相等，因此不会触发唯一性冲突。

**问：唯一索引查询为何更快？**
答：匹配到一个唯一值后即可结束查找，无需继续扫描范围。

**问：更新唯一键列时内部发生了什么？**
答：相当于 “DELETE 旧索引项 + INSERT 新索引项”，因此更新成本更高。

**问：唯一索引冲突是怎么阻塞并发写的？**
答：事务在访问唯一键时获得 X 锁，后续事务需要等待此锁释放。

**问：普通索引能否替代唯一索引？**
答：不能。普通索引不做唯一性校验，只能用于加速查询。

**问：唯一索引是否影响事务隔离？**
答：不会，但锁范围可能扩大，从而影响并发度。

**问：高并发场景唯一索引会引发什么问题？**
答：热点键会导致加锁串行化，引发写入瓶颈和长事务等待。

---

## 4）示意图（ASCII）

```
       唯一索引写入路径（InnoDB）

        INSERT/UPDATE 请求
                |
                v
     查唯一索引 B+Tree 是否存在键
                |
         加锁（X / next-key）
                |
     +---------------------------+
     | 已存在 → 报错/失败        |
     | 不存在 → 写入叶子节点     |
     +---------------------------+
                |
            事务提交
```
