### mysql_composite_index_internal

#### 1）10 行极简速记版（纯文本）

✔ 联合索引底层只有一棵 B+Tree
📌 不会自动额外生成 a、ab 索引
🔥 (a,b,c) 能支持 a / ab / abc 的原因是最左前缀
⚠️ 但并不代表真的存在多个索引结构
🧠 存储顺序固定为 a→b→c
🔍 只有从最左字段起才能利用索引范围扫描
📈 查询条件不含 a 时索引彻底失效（跳跃扫描除外）
✨ 索引复合度越高，最左规则越重要
🚀 想同时支持多个组合应评估查询频率建独立索引
✘ 误以为“一次建索引，相当于建了多个”是常见误区

---

#### 2）折叠式知识卡片版

<details>
<summary>定义</summary>

联合索引 `(a,b,c)` 是一棵包含多个列值的复合 B+Tree 索引。MySQL 不会为其中的 a、ab 自动生成多棵独立索引，所有列都以字典序组合存储在同一棵索引树中。

</details>

<details>
<summary>原理</summary>

* B+Tree 节点存储索引键值的组合 `(a,b,c)`。
* 索引记录在物理存储上按照 `a → b → c` 的字典序排序。
* 查询能否使用该索引只取决于“最左前缀匹配”，即使用索引前缀字段即可。
* 因此前缀 `(a)`、`(a,b)`、`(a,b,c)` 都能走索引，但这是同一棵树在不同层级上的扫描方式。

</details>

<details>
<summary>关键点</summary>

* **联合索引只有一棵，不会生成 a、ab、abc 三棵树。**
* 能支持多种前缀查询是因为排序次序而非多个索引存在。
* 不包含最左列 `a` 的查询通常无法使用索引（MySQL 8.0 引入跳跃扫描作为特例）。
* 索引设计应基于查询模式，而不是误解联合索引可以取代单列索引。

</details>

<details>
<summary>扩展知识</summary>

* MySQL 8.0 的 index skip scan 可以让部分不含 a 的查询利用部分索引（性能有限，成本高）。
* 联合索引中过长的字段会影响整个索引体积和页利用率。
* 查询中字段顺序不影响能否使用联合索引，关键是出现了最左前缀。
* `(a,b,c)` 覆盖 `(a)` 和 `(a,b)` 的过滤，但不等价于真正的单列或双列索引。

</details>

---

#### 3）面试官追问（Q&A）

**问：为什么 (a,b,c) 的联合索引能支持 a 或 ab 查询？**
答：因为联合索引按 a→b→c 排序，a 本身就是索引前缀，扫描可从 a 区间开始。

**问：既然能支持 a 查询，是否等价于同时创建 a 索引？**
答：不是。单列 a 索引更小、更高效；联合索引前缀扫描的成本通常更高。

**问：为什么不包含 a 的查询不能利用 (a,b,c)？**
答：因为无法通过 b 或 c 定位树的起点，不满足最左前缀规则。

**问：MySQL 8.0 的 skip scan 是否能解决此问题？**
答：部分能，但代价高、范围扫描多，不建议替代真正的合适索引。

**问：如何选择联合索引字段顺序？**
答：按过滤选择性、常用查询模式、排序需求综合决定，通常将选择性最高的字段放最左。**

**问：联合索引是否会用于排序？**
答：如果 ORDER BY 顺序与索引前缀一致，可避免 filesort，否则不行。

---

#### 4）示意图（ASCII）

```
联合索引 (a,b,c) 树的结构（单棵）

        a1,b1,c1
        a1,b1,c3
        a1,b2,c1
        a2,b1,c2
        a2,b3,c1
        a3,b1,c4
        ...

最左前缀可用：
(a)
(a,b)
(a,b,c)

不可用：
(b)
(b,c)
(c)
```