✔ 主键不必须自增，但工程上几乎都建议
🚀 自增主键 = 顺序写入 = 最少页分裂
📌 主键顺序即插入顺序，B+Tree 更稳定
🧠 自增键体积小、可预测、IO 成本低
⚠️ 自增主键可能不连续（回滚/删除/失败）
🔥 无主键时 InnoDB 会自动生成隐藏 row_id
🔍 隐藏主键同样自增但对用户不可见
📈 隐藏主键比业务主键更难维护、更占空间
➤ 非自增主键（如 uuid）会导致严重页分裂
✔ 写入性能敏感场景必须避免随机主键

---

## 2）折叠式知识卡片版

<details>
<summary>定义</summary>

* **主键（Primary Key）**：唯一标识一条记录的列，不要求必须自增。
* **自增主键（AUTO_INCREMENT）**：主键递增插入，保证物理写入顺序稳定。
* **隐藏主键（row_id）**：无主键/唯一非空索引时 InnoDB 自动创建的 6 字节内部自增键。

</details>

<details>
<summary>原理</summary>

1. **自增主键带来物理有序插入**

    * B+Tree 叶子节点按照主键顺序追加
    * 插入永远发生在“右侧”，避免大量页分裂
    * I/O、锁竞争、缓存命中率最佳

2. **非自增主键（如 UUID）是随机插入**

    * 会频繁在中间节点插入
    * 触发页分裂、页合并、碎片化
    * 导致写入放大 + 查询退化
    * 对高写入压力系统影响巨大

3. **隐藏主键机制**

    * 无主键 → 选唯一非空索引
    * 若无唯一索引 → 创建 6 字节自增 row_id
    * row_id 不可显示使用，但仍占空间、仍维护结构

</details>

<details>
<summary>关键点</summary>

* 自增主键是性能最优的聚簇索引形式
* 不连续自增是正常现象（删除/回滚/失败不会回填）
* 隐藏主键不透明、不可控，不推荐依赖
* 随机主键会导致写性能显著下降
* 自增主键对二级索引更友好（更小、排序稳定）
* 主键决定了表中数据的物理存储顺序

</details>

<details>
<summary>扩展知识</summary>

* 逻辑主键 ≠ 物理主键，可使用自增键做物理主键，业务字段加唯一索引。
* 分布式系统中若必须使用全局唯一 ID，可考虑雪花算法，但仍需保证近似有序。
* 超大表高写压力场景，自增主键可显著降低页分裂率与 undo/redo 压力。

</details>

---

## 3）面试官追问（Q&A）

**问：为什么自增主键比 UUID 主键快很多？**
答：UUID 是随机写，会打乱 B+Tree，导致大量页分裂；自增主键是顺序写，IO 成本最低。

**问：主键不连续是否是异常？**
答：不是。回滚、删除、事务失败都会消耗主键，但不会回填。

**问：隐藏主键 row_id 有什么缺点？**
答：不可见、不可控、多列唯一索引仍需维护，且会增大行记录大小。

**问：主键选择对非聚簇索引有什么影响？**
答：二级索引叶子节点存储主键值，主键越大，二级索引越臃肿。

**问：随机主键为什么容易死锁？**
答：因为插入位置不可预测，多个事务可能争用中间页，竞争范围更大。

**问：表没有主键会怎样？**
答：InnoDB 会自动创建隐藏主键，但不建议依赖，管理难、空间浪费。

**问：是否可以用业务字段做主键？**
答：可以，但需评估字段长度、修改风险、区分度、是否会造成写入离散化。

---

## 4）示意图（ASCII）

```
自增主键插入（顺序）：
B+Tree ->
[1][2][3][4] → append 5 (无页分裂)

随机主键插入（UUID）：
[1][3][7][10]
      ↑ 插入 5 → 页分裂 → IO 放大

隐藏主键结构：
Row:
| row_id | other columns... |
```
