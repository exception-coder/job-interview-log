a_b_index_selection

✔ 优化器会在 a、b 两个单列索引中择优
🔥 选择性高者优先被选为访问路径
📌 任一索引失效则只能走另一边
🚀 也可能触发 index merge 同时用俩索引
⚠️ 函数/类型转换导致索引失效要警惕
🔍 无联合索引时 index merge 是兜底
📈 AND 场景常用 intersect 取交集
🧠 选错索引多因统计信息不准
➤ 复合索引永远优于两个单列索引
✘ 依赖优化器“自动选择”风险很大

---

<details>
<summary>定义</summary>

**单列索引选择**：当 SQL 为 `WHERE a = xx AND b = xx` 且表上只有 a、b 两个单列索引时，优化器会在这两个索引之间选择一个最优的访问路径。

**索引合并（index merge）**：MySQL 将多个单列索引分别扫描并合并，得到最终结果集的一种执行策略。

</details>

<details>
<summary>原理</summary>

* 优化器基于成本模型（选择性、基数、过滤率、统计信息等）在 a、b 两个索引中择优。
* 若一方索引因函数使用、类型转换等原因失效，优化器仅能使用另一索引。
* 当两个索引都具有较高过滤性时，可能触发 index merge，通过 intersect 方式取交集。
* 若存在复合索引 `(a,b)` 或 `(b,a)`，则远优于任意单列或 index merge。

</details>

<details>
<summary>关键点</summary>

* 没联合索引 → 默认从 a、b 中择优一个。
* 任一索引失效 → 只能走剩下那一个。
* 同时走两个索引 → 发生在 index merge 启用且两个索引选择性都不错时。
* index merge 并不代表更快，其回表成本通常高于复合索引。
* 选错索引很常见，与统计信息准确度强相关。

</details>

<details>
<summary>扩展知识</summary>

* 可通过 EXPLAIN 检查 type=index_merge、key=idx_a,idx_b 判断是否触发索引合并。
* index merge 是 MySQL 5.1 引入的策略，包含 intersect、union、sort_union 三种方式（合理补充说明）。
* 强制索引（force index）可能让优化器走低效路径，应谨慎使用（合理补充）。

</details>

---

**问：优化器如何在 a、b 两个索引中选择？
答：根据选择性、基数、过滤率、统计信息估算成本，挑最便宜的路径。**

**问：会同时使用两个索引吗？
答：会，在 index merge 被启用且两个索引都能显著过滤时会触发 intersect 合并。**

**问：函数或类型转换会影响索引选择吗？
答：会，若导致 a 或 b 索引失效，则优化器只能使用另一索引。**

**问：为什么复合索引比单列索引更好？
答：复合索引无需合并结果，过滤更高效，也减少回表次数。**

**问：index merge 会更快吗？
答：不一定，多数情况下不如复合索引，且结果合并与回表成本较高。**

**问：如何判断是否发生了 index merge？
答：EXPLAIN 中 type=index_merge 且 key 字段包含多个索引。**

**问：为什么会出现“选错索引”？
答：统计信息过期、基数估计不准或执行计划成本预测失衡导致。**

**问：如何避免优化器选错？
答：更新统计信息、创建合理复合索引、必要时使用 hint/force index（慎用）。**

---

```
        ┌────────────────────────┐
        │  WHERE a=xx AND b=xx   │
        └───────────┬────────────┘
                    │
     ┌──────────────┴───────────────┐
     │                              │
┌──────────────┐            ┌────────────────┐
│ 选单一索引      │            │ index merge       │
│ 选择性更高者优先 │            │ a、b 两索引交集合并 │
└──────────────┘            └────────────────┘
```
