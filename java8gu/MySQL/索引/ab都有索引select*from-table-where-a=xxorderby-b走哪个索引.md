### mysql_index_choice_a_eq_xx_order_by_b

#### 1）10 行极简速记版（纯文本）

✔ a、b 各有索引但不保证用 a
📌 优化器按成本选“最便宜”的索引
🔥 a 选择性高 → 先过滤再排序
🚀 a 选择性低 → 可能直接走 b 索引
⚠️ b 索引能避免排序成本时优先
🔍 基数、选择性、排序代价都会影响
🧠 WHERE 过滤 vs ORDER BY 排序权衡
📈 若排序代价巨大，倾向使用 b
✨ 优化器是 CBO，不是固定规则
✘ 不创建(a,b)联合索引很难同时兼顾

---

#### 2）折叠式知识卡片版

<details>
<summary>定义</summary>

在 `SELECT * FROM table WHERE a = xx ORDER BY b` 中，字段 a 和字段 b 各自都有单列索引。MySQL 在执行时会在 a 索引和 b 索引之间做选择，依据代价模型（CBO）决定哪个路径更便宜。

</details>

<details>
<summary>原理</summary>

* 若 `a = xx` 的过滤选择性高，使用 a 索引可直接定位极少量记录，此时排序成本也低，总成本更小。
* 若 `a = xx` 选择性低（匹配大量行），使用 a 索引后仍需对大量记录排序；而 b 索引自身有序，直接按 b 顺序扫描更便宜。
* MySQL 优化器会评估：过滤成本 + 回表成本 + 排序成本 → 选最优执行计划。
* 无固定规则，完全依赖数据分布与索引统计信息。

</details>

<details>
<summary>关键点</summary>

* 选择性（distinct/total）影响过滤成本，是选择索引的重要指标。
* 排序代价高，优化器倾向直接使用 b 索引避免排序。
* 使用 a 索引时 ORDER BY b 需 filesort；使用 b 索引时可自然顺序扫描避免排序。
* MySQL 优化器会根据统计信息动态选择执行计划。
* 仅建单列索引无法同时兼顾过滤和排序。

</details>

<details>
<summary>扩展知识</summary>

* 若该查询频繁出现，应创建联合索引 `(a,b)`，能同时满足过滤和排序，是最优结构。
* 若数据分布变化大，统计信息老化，会导致错误的索引选择。
* 可用 `FORCE INDEX` 临时强制优化器走指定索引（不推荐长期使用）。
* 可用 `EXPLAIN` 查看当前数据库版本与统计数据下的选择逻辑。

</details>

---

#### 3）面试官追问（Q&A）

**问：为什么 MySQL 在 a 的选择性低时会选择 b 的索引？
答：因为使用 a 索引后需要对大量结果排序，而走 b 索引可避免排序，成本更低。**

**问：优化器是如何决定用 a 还是 b？
答：基于 CBO（Cost-Based Optimizer），根据行扫描量、选择性、排序代价等综合评估成本。**

**问：为什么 a、b 各有索引还会排序很慢？
答：用 a 索引过滤后 ORDER BY b 必须 filesort，无法利用 b 的有序性。**

**问：想让查询始终又快过滤又快排序该怎么做？
答：创建 `(a,b)` 联合索引，让 WHERE 和 ORDER BY 同时基于索引执行。**

**问：哪些场景下优化器可能“选错”索引？
答：统计信息不准、数据分布倾斜、前缀索引选择性低等都会误导优化器。**

**问：如何判断 MySQL 当前用的是哪个索引？
答：使用 EXPLAIN，看 key / key_len / rows / Extra 是否出现 Using filesort。**

**问：ORDER BY b 能否强制利用排序索引？
答：可以用 FORCE INDEX(b)，但不推荐；更优解是建联合索引。**

---

#### 4）示意图（ASCII）

```
查询：WHERE a = xx ORDER BY b

索引选择流程（简化版）：
          ┌──────────────┐
          │ 计算 a 过滤成本 │
          └──────────────┘
                   │
                   ▼
          ┌──────────────┐
          │ 计算 b 排序成本 │
          └──────────────┘
                   │
                   ▼
      ┌────────────────────────┐
      │ 选择总成本最低的索引路径 │
      └────────────────────────┘

可能路线：
1) 走 a 索引 → 过滤少量行 → 再 filesort 依 b 排序
2) 走 b 索引 → 按 b 值天然有序 → 再过滤 a（成本取决于行数）
```

如需，我可以继续补充 `(a,b)` 联合索引为何最优、filesort 成本模型解析等更深入内容。
