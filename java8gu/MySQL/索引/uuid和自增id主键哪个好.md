✔ UUID 全局唯一但极度随机，写入代价高
🚀 自增 ID 顺序写入最友好，页分裂最少
📌 UUID 索引臃肿、缓存命中率低
🧠 UUID 不可预测更安全，但难展示
⚠️ 自增 ID 有上限、可预测、分库需额外方案
🔥 UUID 适合分布式；自增 ID 适合单库高性能
🔍 UUID 4 随机性强；UUID 7 支持有序但未原生支持
📈 自增键更利于分页、排序、深度翻页
➤ 高写入 QPS 系统优先自增或类自增算法（雪花）
✔ 随机主键会触发大量页分裂，必须慎用

---

## 2）折叠式知识卡片版

<details>
<summary>定义</summary>

* **UUID**：128 bit 全局唯一标识符，常用 v1（时间+MAC）或 v4（随机）。
* **自增主键（AUTO_INCREMENT）**：依次递增的整数主键，是 InnoDB 最友好的主键形式。
* 二者都可作为主键，但行为与性能差异巨大。

</details>

<details>
<summary>原理</summary>

### UUID 主键

* 值随机，插入 B+Tree 时位置不可预测 → 频繁在中间插入
* 导致 **大量页分裂、页合并、B+Tree 失衡**
* 索引体积大（16 bytes vs bigint 8 bytes）→ buffer pool 命中率下降
* 影响范围查询（无序）与排序

### 自增主键

* 顺序追加 → 始终在右端插入
* **极少页分裂**、写放大最低
* 主键小、索引紧凑 → 缓存友好
* 更利于分页（基于 ID 的深分页优化）

</details>

<details>
<summary>关键点</summary>

* UUID 适合分布式、无中心 ID 发号场景，但写入性能差
* UUID 难展示、无业务意义
* 自增主键可预测、存在上限、在分库环境中不可直接使用
* 二级索引存主键值 → 主键越大越拖慢二级索引
* 大表高写场景，自增主键优势明显
* UUID v7 提供有序特性，但 Java/MySQL 尚未原生支持

</details>

<details>
<summary>扩展知识</summary>

* 分布式系统常使用 **雪花算法（Snowflake）** 替代 UUID：有序、短、分布式唯一
* 如果没有主键，InnoDB 会生成隐藏 row_id，但不推荐依赖
* 可使用 “逻辑主键 + 自增物理主键” 组合模式

</details>

---

## 3）面试官追问（Q&A）

**问：UUID 为什么会导致写入变慢？**
答：随机插入破坏 B+Tree 有序性，频繁触发页分裂、页移动、随机 IO。

**问：为什么自增主键更适合作为聚簇索引？**
答：InnoDB 聚簇索引按主键顺序存储，自增带来顺序写，极大减少结构维护开销。

**问：UUID v4 和 UUID v7 的区别是什么？**
答：v4 随机、无序；v7 基于时间戳，有序，可用于替代自增，但生态尚不成熟。

**问：自增主键在分库分表场景下怎么办？**
答：不能直接使用本地自增，可改用雪花算法、号段模式等分布式 ID。

**问：UUID 索引比自增主键大多少？为什么重要？**
答：UUID 16 字节，自增 bigint 8 字节；二级索引叶子节点会存主键，影响缓存与 IO。

**问：业务字段可以当主键吗？**
答：可以，但若字段较长或会更新，会极大影响写入性能和索引维护。

---

## 4）示意图（ASCII）

```
自增主键（顺序写）：
[1][2][3][4] --> append 5  (无页分裂)

UUID（随机写）：
[1][5c3e][7a91][f02a]
      ↑ 插入新 UUID → 中间插入 → 页分裂 + IO 放大

二级索引结构：
Leaf: (index_key, primary_key)
UUID 主键过大 → 二级索引整体变大
```
