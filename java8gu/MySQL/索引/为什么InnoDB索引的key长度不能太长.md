innodb_key_length_limit

✔ key 越长，B+树节点能装的记录越少
🔥 页利用率下降 → B+树变深 → I/O 增加
📌 16KB 页固定大小决定了索引长度不能任性扩
🚀 key 比较越长，CPU 比较成本越高
⚠️ 长字符串索引极易造成树膨胀
🧠 磁盘随机 I/O 是瓶颈，深树代价巨大
📈 索引长度要在“区分度 vs 长度”间权衡
🔍 前缀索引常用于控制 key 长度
➤ 根/非叶节点变大加剧缓存失效
✘ key 过短又会导致区分度不足

---

<details>
<summary>定义</summary>

**索引 key 长度**：B+树索引中每个节点存储的键值字节数，包含字段本身及必要的元数据。InnoDB 以 16KB 页为存储基本单元，节点容量直接受 key 长度影响。

</details>

<details>
<summary>原理</summary>

* InnoDB 索引节点对应数据页（16KB 为单位），key 越长单页可容纳的索引条目越少。
* 页内容量下降 → 需更多页才能容纳相同数据量 → B+树高度增加。
* B+树查找需逐层读取节点，树越深磁盘 I/O 越多，延迟成倍上升。
* 长 key 的比较代价也更高，尤其是变长字符串，导致 CPU 消耗加剧。
* 高层（根节点/非叶节点）膨胀还会降低 buffer pool 缓存命中率，使访问更频繁落盘。

</details>

<details>
<summary>关键点</summary>

* 16KB 页大小限制了单页可存储的索引条目数，决定了 key 长度的上限。
* key 越大 → B+树越深 → 查找/更新/插入全被放慢。
* 高长度字符串索引显著影响随机 IO，尤其在高读写量场景下。
* key 不宜过短，否则区分度不足，扫描行数变多。
* 实际工程会在“索引选择性”和“key 长度”间权衡，例如使用前缀索引。

</details>

<details>
<summary>扩展知识</summary>

* 前缀索引与全字段索引对比：节省空间但可能降低区分度（合理补充）。
* B+树缓存特性决定：非叶节点越小，越容易全部驻留在 buffer pool 中，提高性能（合理补充）。
* 大字段（TEXT/BLOB）不可直接建索引，需要前缀以控制 key 长度。

</details>

---

**问：为什么 key 长度会导致 B+ 树变深？
答：页大小固定，key 越大节点越少，需更多页容纳同样数量的数据，树高度自然增长。**

**问：树变深具体会影响什么？
答：每次查询都需更多随机 I/O；插入、删除也会触发更多页分裂与合并。**

**问：为什么长 key 会增加 CPU 负载？
答：字符串比较需要逐字符比较，key 越长开销越大，尤其在非叶节点大量重复比较时明显。**

**问：如何降低长 key 的负担？
答：使用前缀索引、哈希索引（如在应用层存 hash）、拆分字段。**

**问：是否可以随意增大 InnoDB 页大小解决？
答：页大小可调但不建议随意调整，会影响表结构兼容性与其他操作成本（合理补充）。**

**问：key 过短有什么坏处？
答：区分度不够，扫描行数变多，容易导致索引选错或直接全表扫描。**

**问：为什么身份证前 6 位不能作为索引？
答：重复度极高，基数低，过滤性差，等价于没索引。**

**问：如何判断索引长度是否合理？
答：看基数（cardinality）、分布特征、查询模式；必要时通过 EXPLAIN 验证。**

---

```
          ┌────────────────────┐
          │     InnoDB B+树     │
          └─────────┬──────────┘
                    │
      ┌─────────────┴──────────────┐
      │                              │
┌──────────────┐           ┌────────────────┐
│ key 过长的影响 │           │ key 过短的影响    │
├──────────────┤           ├────────────────┤
│ 页容量减少     │           │ 区分度不足         │
│ 树高度增加     │           │ 扫描行数上升       │
│ I/O 变多       │           │ 优化器倾向放弃索引   │
└──────────────┘           └────────────────┘
```
