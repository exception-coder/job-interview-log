MySQL_Wrong_Index_Choice
✔ 优化器基于成本选索引，不保证最优
⚠️ 统计信息不准是最大元凶
📌 基数性/选择性决定扫描行数
🧠 覆盖索引强吸引优化器
🔥 ORDER BY 会诱导选择有序索引
➤ 复杂 SQL 易让优化器误判成本
📈 FORCE INDEX 是兜底但需谨慎
✨ ANALYZE TABLE 能校准统计信息

---

## 折叠式知识卡片版

<details>
<summary>① 定义</summary>

* MySQL 使用 **CBO（基于成本的优化器）** 决定走哪个索引。
* 索引选择基于统计信息估算扫描代价，并非固定规则。
* 文档阐述索引选择影响因素及选错索引的原因和解决方案。

</details>

<details>
<summary>② 原理</summary>

### 优化器如何决策？

* **基数性（Cardinality）**：不同值数量越多，区分度越好 → 更倾向使用。
* **选择性（Selectivity）**：过滤能力越强，扫描越少。
* **索引覆盖性**：若索引包含查询所需全部字段 → 优化器优先选。
* **ORDER BY 匹配**：能减少排序成本的索引优先。
* **JOIN 顺序和访问类型**：多表查询时更复杂。
* **索引深度/大小/系统资源限制** 都会影响估算。

### 为什么会选错？

* **统计信息过时或不准** → 错误估计扫描行数。
* **复杂 SQL**（子查询、多 JOIN、函数）让优化器难以准确评估成本。
* **系统参数限制** 影响优化器策略。

</details>

<details>
<summary>③ 关键点</summary>

* 优化器不是基于语法，而是基于“预估成本”决定索引。
* 统计信息错误（基数估计不准） → 最常见的选错原因。
* 高选择性、覆盖索引往往更容易被选中。
* ORDER BY 会让优化器优先考虑“有序索引”，即便过滤性差。
* 强制索引（FORCE INDEX）可解决问题，但数据分布变化后可能误导优化器。

</details>

<details>
<summary>④ 扩展知识</summary>

* MySQL 的统计信息并非实时更新，而是采样估计，存在偏差（合理补充）。
* 对大表推荐使用 **persistent statistics**（持久统计）提高稳定性。
* 索引维护不当可能导致覆盖索引变大、深度增加，降低成本估计准确性。

</details>

---

## 面试官追问（Q&A）

**问：为什么基数性越高越容易被选用？**
答：高基数表明区分度好，优化器认为扫描行数少，成本低。

**问：ORDER BY 为什么会影响索引选择？**
答：使用有序索引可避免 file sort，优化器会优先考虑减少排序的计划。

**问：统计信息为什么会不准？**
答：InnoDB 基于采样统计，不保证覆盖全表；高更新表更容易失真。

**问：FORCE INDEX 有什么风险？**
答：数据分布变化后，强制索引可能导致反向优化，性能变差。

**问：如何判断 MySQL 选错了索引？**
答：用 EXPLAIN 查看 rows、filtered、key，与实际行数对比，若扫描量异常大即不合理。

**问：更新统计信息的最佳时机？**
答：表数据大量变更后（例如批量导入、删除），可手动 `ANALYZE TABLE`。

**问：复杂 SQL 为什么更容易误选索引？**
答：优化器对多 JOIN、多谓词组合的成本估计误差叠加，导致误判。

---

## 示意图（ASCII）

```
优化器索引决策流程（简化）

     所有可用索引
           │
           ▼
   统计信息（基数/选择性）
           │
           ▼
   成本预估（扫描行数/排序/访问方式）
           │
           ▼
   选择成本最低的执行路径
```

（完）
