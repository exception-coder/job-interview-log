index_invalid_but_faster

✔ 小表全表扫比走索引更快
🔥 低过滤性索引命中太多行反而拖慢
📌 数据倾斜严重时索引代价更高
🚀 force index 反而可能逼优化器走错
⚠️ 让“错误索引”失效可提升性能
➤ order by 场景常被误选主键索引
🔍 过滤性强的索引优先级通常更高
🧠 索引失效本质是成本模型选择
📈 均匀分布 vs 倾斜：优化器判断偏差
✘ 错误索引设计导致频繁选错路径

---

<details>
<summary>定义</summary>

**索引失效**：查询语句由于优化器成本模型判断，全表扫描或使用非预期索引，导致未命中本应有利的索引。部分情况下，有意让某些索引失效反而能提升效率。

**索引选错**：当多个可用索引存在时，优化器误判成本，使用了低效索引，导致查询变慢。

</details>

<details>
<summary>原理</summary>

* 优化器根据统计信息估算成本：包括过滤性、基数、数据分布、排序需求等。
* 小表数据量小，全表扫描的顺序读取成本通常低于走索引的随机 I/O。
* 低过滤性（命中大量数据）或数据严重倾斜时，走索引需大量回表，成本高于直接扫表。
* ORDER BY 会增加优化器对可用于排序的索引（如主键）的偏好，即使过滤性较弱。
* 使用函数、表达式或隐式类型转换可让特定索引失效，从而引导优化器使用更优的索引。

</details>

<details>
<summary>关键点</summary>

* **小表**：全表扫描几乎总是最优。
* **过滤性差**：返回行数大时走索引不划算。
* **数据倾斜**：部分值集中，基数统计不准确导致优化器误判。
* **force index 风险**：强制使用本不该用的索引会显著变慢。
* **让索引失效=提升性能**：通过函数或条件重写迫使优化器选更优路径。
* **ORDER BY + LIMIT 容易误导优化器**：特别是主键递增表。

</details>

<details>
<summary>扩展知识</summary>

* InnoDB 的统计信息并非实时，可能过期导致优化器判断偏差（合理补充）。
* 可通过 `ANALYZE TABLE` 刷新统计，提高索引选择准确性（合理补充）。
* 使用 `EXPLAIN` 分析实际索引选择路径，结合慢 SQL 排查。

</details>

---

**问：哪些情况下索引会被优化器主动放弃？
答：小表、过滤性差、数据倾斜严重、查询返回大量行、排序需求与索引不匹配等情况。**

**问：为什么全表扫描有时更快？
答：顺序 I/O 成本低，且避免大量随机回表访问；在小表或低过滤场景下更优。**

**问：优化器为什么会选错索引？
答：统计信息不准、基数估计偏差、分布倾斜、排序需求权重偏高、复杂条件导致误判等。**

**问：如何人为让某个索引失效？
答：对字段使用函数（如 `id + 0`、`CAST(id AS CHAR)`）、计算表达式或类型转换。**

**问：force index 是否可靠？
答：风险大，可能强制走低效路径，应在验证过滤性与查询行为后再使用。**

**问：ORDER BY 为什么容易导致索引误选？
答：优化器倾向选择可完成排序的索引（如主键），即使过滤性弱，从而导致回表成本升高。**

**问：如何判断某个索引过滤性好不好？
答：可通过 `SHOW INDEX` 查看 `cardinality`，或用 `COUNT(DISTINCT col)` 估算基数。**

**问：统计信息过期会带来什么影响？
答：优化器根据错误估计选择错误执行计划，常导致索引选错或索引被放弃。**

---

```
          ┌──────────────┐
          │ 优化器成本模型 │
          └───────┬──────┘
                  │
     ┌────────────┴────────────┐
     │                         │
┌──────────────┐        ┌────────────────┐
│ 走索引更慢的场景 │        │ 索引失效反提速情形 │
├──────────────┤        ├────────────────┤
│ 小表          │        │ 让错误索引失效     │
│ 低过滤性      │        │ 强过滤索引被选中   │
│ 数据倾斜      │        │ 避免主键排序误选   │
└──────────────┘        └────────────────┘
```
