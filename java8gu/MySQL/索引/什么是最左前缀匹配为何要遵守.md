zuozuo_qianzui_pipei

✔ 最左前缀匹配=联合索引按最左字段优先匹配
🚀 (a,b,c) 索引的排序规则是先 a，再 a 下的 b，再 a,b 下的 c
📌 where 条件必须包含最左列才能用到索引
🧠 查询条件顺序无关，优化器会重排
⚠️ (b,c) 或单独 c 查询无法利用联合索引
🔥 like 'abc%' 能走索引，但 '%abc' 无法走索引
🔍 最左前缀应用于联合索引和前缀模糊匹配
📈 B+Tree 物理结构决定必须按最左键扫描
➤ 注意索引跳跃扫描不是常规可依赖能力
✔ 不存在“一次建三棵树”，联合索引本质只有一棵 B+Tree

---

## 2）折叠式知识卡片版

<details>
<summary>定义</summary>

* **最左前缀匹配**：
  查询条件必须从联合索引的最左列开始连续匹配，才能使用该索引。

* **联合索引 (col1,col2,col3)** 的可用匹配范围：

    * 可用：`col1`、`col1+col2`、`col1+col2+col3`
    * 可用但退化：`col1+col3`（只用到 col1）
    * 不可用：只用 `col2`、`col3` 或 `(col2,col3)`

</details>

<details>
<summary>原理</summary>

* B+Tree 构建联合索引时的顺序：

    1. 先按 col1 排序
    2. col1 相同时按 col2 排序
    3. col1,col2 都相同时按 col3 排序

* 因此查询时也必须按同样顺序才能利用顺序扫描。

* 如果不包含最左列（col1），则索引树定位起点无法确定 → 不能高效使用索引。

* 模糊匹配中 `like 'abc%'` 可用索引，因为前缀有效；但 `%abc` 前缀未知 → 无法定位。

</details>

<details>
<summary>关键点</summary>

* 最左前缀与 SQL 条件顺序无关，优化器会智能重排。
* 单字段索引同样适用最左前缀规则（like 场景）。
* 联合索引不是多个索引的组合，而是“一棵 B+Tree”。
* 尽量让过滤性强、常用于 where 的字段在前。
* 无法满足最左前缀时可考虑索引跳跃扫描，但依赖条件多，不可作为主流方案。

</details>

<details>
<summary>扩展知识</summary>

* 索引跳跃扫描（Index Skip Scan）在特定版本中存在，但不稳定且依赖数据分布，不应依赖于生产使用。
* 针对大量 like 查询，可考虑前缀索引、倒排索引、全文索引等方式。
* 联合索引字段顺序设计需结合区分度、查询模式及覆盖索引需求综合考量。

</details>

---

## 3）面试官追问（Q&A）

**问：联合索引为什么不能反着匹配？(如只查 col2)**
答：因为 B+Tree 是按照 col1→col2→col3 的顺序物理排序，缺失 col1 时扫描起点无法确定。

**问：查询写成 col2=? and col1=? 会不会影响索引？**
答：不会。优化器会自动调整顺序，仍然满足最左前缀。

**问：like '%xxx' 为什么不能走索引？**
答：前缀未知，索引无法确定起始范围，只能全表扫描。

**问：建立联合索引 (a,b,c) 时数据库是否建立了三个索引？**
答：没有，只建立一棵 B+Tree，只是节点中依次比较 a→b→c。

**问：如何判断是否命中最左前缀？**
答：看 where 条件是否从联合索引最左列连续使用；中间断开（如 a 用了，但 b 没用却用 c）会部分失效。

**问：如果查询只用 col1，会不会比单独 col1 索引慢？**
答：不会。联合索引的前缀 (col1) 可当作 col1 的单独索引使用。

**问：like 'a%' 为什么可以用索引？**
答：字符串前缀已明确可定位 B+Tree 范围。

**问：skip scan 是否能在不使用 col1 的情况下利用索引？**
答：理论可行，但受限版本、数据分布与代价模型，不适合作为工程方案。

</details>

---

## 4）示意图（ASCII）

```
联合索引 (col1, col2, col3) 的 B+Tree 排序结构：

level-1: [col1]
            |
      ----------------
      |              |
   col1=1         col1=2
      |              |
level-2: sorted by col2
      |              |
   col2=5         col2=7
      |              |
level-3: sorted by col3
      |              |
   col3=8         col3=9

=> 查询必须从 col1 开始，才能沿树查找
```
