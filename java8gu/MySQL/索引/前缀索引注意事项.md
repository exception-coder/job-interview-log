### mysql_prefix_index

#### 1）10 行极简速记版（纯文本）

✔ 前缀索引只存前 N 字符，节省空间
📌 适合长字符串字段，如 URL/邮箱/地址
🔥 索引更小 → B+ 树更高效
⚠️ 前缀太短会导致选择性差
✘ 不能做覆盖索引（只存部分值）
🧠 高度相似字段前缀易失效
📈 前缀长度需根据数据分布计算
🔍 选择性=不重复前缀数/总记录
✨ LEFT() + COUNT(DISTINCT) 评估最佳 N
🚀 合理前缀可显著提升查询性能

---

#### 2）折叠式知识卡片版

<details>
<summary>定义</summary>

前缀索引是对字符串字段仅提取前 N 个字符建立索引的技术，用于减少索引占用，提高 B+Tree 索引效率，适用于 VARCHAR、TEXT 等长字段。

</details>

<details>
<summary>原理</summary>

* B+Tree 索引存储字段完整值，长字段导致节点容量下降。
* 通过 `INDEX(column(N))` 仅存前 N 字符，可显著缩小索引体积。
* 查询时依然走索引，但无法做到完整字段匹配，需要回表验证真实值。

</details>

<details>
<summary>关键点</summary>

* 前缀越短，选择性可能越差，查询过滤能力下降。
* 不支持覆盖索引（因为不存完整字段）。
* 过短会导致大量重复键，影响优化器选择。
* N 的选择应通过统计数据分布计算。
* 不适合字段前缀统一或规律性强的场景（如身份证/手机号前几位）。

</details>

<details>
<summary>扩展知识</summary>

* 可通过 `COUNT(DISTINCT LEFT(col,N)) / COUNT(*)` 评估 N 的选择性。
* 若字段分布高度集中，可考虑 Hash 前缀索引（文中未涉及，此为合理补充）。
* 选择性低可能导致死锁风险上升（文中案例引用）。
* 优化器依赖选择性的成本估算，前缀错误会导致错选索引。

</details>

---

#### 3）面试官追问（Q&A）

**问：前缀索引为什么能提升性能？
答：索引更小 → B+Tree 节点更多 → 树高度更低 → 读页更少 → 查询更快。**

**问：前缀索引为何不能用于覆盖索引？
答：覆盖索引需字段完整值，而前缀索引只存部分内容，不满足覆盖要求。**

**问：如何判断前缀长度是否合适？
答：计算选择性：`COUNT(DISTINCT LEFT(col,N))/COUNT(*)`，接近 1 表示过滤效果好。**

**问：哪些字段不适合做前缀索引？
答：前几位高度相似的字段，如身份证、手机号、MD5 前几位等，选择性极低。**

**问：使用前缀索引可能导致什么问题？
答：过滤能力差，导致 MySQL 回表量增加；可能导致优化器选错索引；甚至引发死锁问题（文中提及）。**

**问：为什么不能让前缀尽量长？
答：过长前缀失去节省空间意义，等同建立完整索引。**

**问：前缀索引对范围查询有效吗？
答：可用，但过滤效果依赖前缀选择性，前缀差可能导致全索引扫描。**

**问：前缀索引会影响排序吗？
答：索引排序基于前 N 字符，大部分情况仍能利用 B+Tree，但需要回表校验完整顺序。**

---

#### 4）示意图（ASCII）

```
原字段（VARCHAR(255)）示例：
[abcdefghijk....]

前缀索引 N=10：
[abcdefghij]

B+Tree 存储对比：
完整索引节点：值长，单页存储少 → 树高
前缀索引节点：值短，单页存储多 → 树低

字段分布选择性计算：
col -----> LEFT(col, N) -----> DISTINCT 计数
```

```
前缀长度评估流程：
数据采样
   ↓
计算各 N 的选择性
   ↓
选择 selectivity 接近 1 的最小 N
```

如果需要，我可以继续生成「如何挑选最佳前缀长度」「前缀索引常见踩坑」等工程实践补充。
