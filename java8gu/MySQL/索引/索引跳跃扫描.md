总结标题：mysql_index_skip_scan

---

## 1）10 行极简速记版（纯文本）

🔥 Skip Scan 允许跳过最左前缀也能用上联合索引
✔ MySQL 8.0.13+ 支持，对 5.7 完全不适用
📌 原理：枚举左列所有唯一值 → 构造多组 range 查询
🚀 适用于左列区分度低、右列过滤强的场景
⚠️ 左列基数高时 Skip Scan 反而更慢
✨ EXPLAIN Extra 显示 “Using index for skip scan”
🔍 type=range、rows 大幅下降是关键信号
🧠 本质是优化器自动拆分成多段范围查
📈 不能用于 JOIN、GROUP BY、DISTINCT 等复杂查询
✘ 不可因 Skip Scan 而错误设计索引顺序

---

## 2）折叠式知识卡片版（Markdown）

<details>
<summary>定义</summary>

索引跳跃扫描（Index Skip Scan）是 MySQL 8.0.13 引入的一项优化，用于支持**未命中联合索引最左前缀仍可利用后续索引列**的查询方式。例如联合索引 `(f1, f2)` 下的条件 `WHERE f2 = 40`，5.7 无法使用索引，而 8.0 可通过 Skip Scan 使用索引减少扫描量。

</details>

<details>
<summary>原理</summary>

Skip Scan 的核心是 **优化器枚举联合索引左列（f1）的唯一值**：

1. 获取 f1 的所有 distinct 值（如 1、2、3...）
2. 对每个值构造 **f1 = X AND f2 = 40** 的范围查询
3. 将所有结果合并返回

等价于：

```
SELECT ... FROM t1 WHERE (f1=1 AND f2=40)
UNION ALL
SELECT ... FROM t1 WHERE (f1=2 AND f2=40)
...
```

* 执行计划中表现为：
  `type = range`
  `extra = Using index for skip scan`
* 与传统的 `type = index` 扫描相比，会大幅减少扫描行数。

</details>

<details>
<summary>关键点</summary>

* Skip Scan 是在**最左前缀无法匹配**时的降级优化。
* 越靠后的列过滤性越强，Skip Scan 越有效。
* 左列（f1）区分度越低（如男女、状态码），越适合 Skip Scan。
* 左列基数很高 → 优化器可能放弃 Skip Scan，因为枚举成本太高。
* 使用范围扫描（range）而非全索引扫描（index），效率显著提升。
* 表必须有联合索引，且查询字段来自索引覆盖。

</details>

<details>
<summary>扩展知识</summary>

* 虽然 Skip Scan 提供了“跳跃”能力，但**索引设计仍必须遵循最左前缀**，不能依赖 Skip Scan 代替正确索引结构。
* Skip Scan 有诸多限制（官方明确）：

    1. 必须单表查询，不能 JOIN
    2. 不支持 GROUP BY、DISTINCT
    3. 查询字段必须在联合索引中
    4. 对于多列联合索引 `(A,B,C,D)`，B/C 必须非 NULL，A/D 可为 NULL
* 适用场景类似 Oracle 的 Skip Scan，但 MySQL 版本机制更轻量。

</details>

---

## 3）面试官追问（Q&A）

**问：Skip Scan 为什么能够打破最左前缀匹配？**
答：因为优化器主动枚举左列所有唯一值，把条件补齐为 `(左列 = X AND 目标列条件)`，再做多次范围扫描，因此达成“跳过前缀”的效果。

**问：Skip Scan 为什么只适合左列区分度低？**
答：若左列唯一值很多，则需要执行大量子范围查询，成本可能比全索引扫描更高。

**问：Skip Scan 与 Index Scan 有什么区别？**
答：Index Scan 是整棵索引树线性扫描；Skip Scan 构造多段 range 扫描，更有选择性，扫描行数显著减少。

**问：为什么 Skip Scan 不适用于 JOIN？**
答：JOIN 中驱动方式复杂，左列枚举与连接代价混在一起，优化器无法安全推断成本。

**问：能否依赖 Skip Scan 来设计联合索引？**
答：不能。Skip Scan 是兜底优化，不是索引设计规则。索引仍必须高选择性列放左侧。

**问：如何判断查询是否发生了 Skip Scan？**
答：EXPLAIN Extra 中出现 “Using index for skip scan”。

**问：Skip Scan 会影响写入或索引结构吗？**
答：不会，它是纯优化器行为，不改变存储结构。

---

## 4）示意图（ASCII）

```
联合索引 (f1, f2)

索引结构：
f1=1 → f2=1..N
f1=2 → f2=1..N
f1=3 → f2=1..N
...

查询：WHERE f2 = 40

Skip Scan 过程：
for each distinct f1:
    do range search (f1 = X AND f2 = 40)
merge results

最终效果：
range 扫描多段小区间，而不是整棵索引 index 扫描
```
