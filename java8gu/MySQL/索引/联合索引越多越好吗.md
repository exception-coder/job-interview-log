Composite_Index_Not_Always_Better
✔ 联合索引不是越多越好
📌 最左前缀决定可用性
⚠️ 索引数量越多，写入成本越高
🔥 过多联合索引会导致频繁页分裂
🔍 冗余索引占用大量存储
🧠 索引覆盖可减少回表但需按需设计
🚀 高选择性列应靠前放
✨ 索引维护成本远大于查询收益

---

## 折叠式知识卡片版

<details>
<summary>① 定义</summary>

* **联合索引（Composite Index）**：由多个字段按顺序组成，满足最左前缀才能发挥作用。
* 本质作用：提升涉及多个条件的查询性能、实现索引覆盖、减少回表次数。

</details>

<details>
<summary>② 原理</summary>

* B+Tree 按联合字段序构建，(a,b,c) 的组织顺序类似 `ORDER BY a,b,c`。
* 查询必须从最左列开始才能利用索引，否则只能部分利用或完全失效。
* 索引越多，维护成本越高：插入/更新需同时维护多个 B+Tree，触发页分裂、页合并。

</details>

<details>
<summary>③ 关键点</summary>

* 联合索引并非越多越好：

    * **占空间**：每个索引都额外占用磁盘与内存（Buffer Pool）。
    * **写入放大**：写入需要维护更多树节点，修改成本增加。
    * **容易冗余**：多个索引可能覆盖同一列组合，降低效率。
* 最左前缀是核心规则，不符合就无法匹配。
* 为查询频率高、区分度高的列设计联合索引才有意义。

</details>

<details>
<summary>④ 扩展知识</summary>

* 索引选择应基于业务真实查询，而非字段多少。
* 冗余索引会导致性能下降，可用 `pt-duplicate-key-checker` 清理（合理补充）。
* 覆盖索引可以避免回表，但要权衡列数量与索引大小。

</details>

---

## 面试官追问（Q&A）

**问：为什么联合索引越多写入越慢？**
答：每次 INSERT/UPDATE 都要维护多个 B+Tree，更多页分裂、页合并导致写放大。

**问：联合索引字段顺序如何决定？**
答：遵循“高选择性字段放前、与过滤相关字段放前、ORDER BY 相关字段优先”的原则。

**问：哪些索引是冗余的？**
答：如果有 (a,b) 索引，再建 (a) 通常是冗余的，因为最左前缀已覆盖 (a)。

**问：为什么最左前缀这么重要？**
答：联合索引是按定义顺序构建的树结构，不从最左列起跳无法做二分查找。

**问：联合索引是否一定比单列索引强？**
答：不一定，如果查询只用到某一列，联合索引可能不如单列高效（深度更大）。

**问：如何判断当前索引是否冗余？**
答：根据查询模式、EXPLAIN 输出、以及是否被覆盖索引包含来判断。

---

## 示意图（ASCII）

```
联合索引 (a,b,c) 的最左前缀规则

Tree order:
   a → b → c

可用情况：
  a           ✔
  a,b         ✔
  a,b,c       ✔

不可用情况：
  b           ✘
  b,c         ✘
  c           ✘
```

（完）
