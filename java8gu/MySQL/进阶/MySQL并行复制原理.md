总结标题
MySQL_Parallel_Replication_Principle

---

## 1）10 行极简速记版（纯文本）

✔ 主从延迟核心瓶颈＝从库单线程回放
🔥 并行复制本质是判断“事务是否互不冲突”
📌 5.6 库级并行＝几乎没用（大多数业务单库）
🚀 5.7 组提交并行＝真正实用的 MTS
🧠 组提交意味着事务之间无锁冲突，可并行回放
📈 8.0 WriteSet：不依赖主库并发度也能并行
➤ WriteSet 通过 PK/UK 哈希判断是否冲突
⚠️ 有相同行更新的事务不能并行
📌 WriteSet 让串行提交也能从库并行
✨ 目标：最大化利用从库 CPU 降低延迟

---

## 2）折叠式知识卡片版（Markdown）

<details>
<summary>① 定义</summary>

**并行复制（Parallel Replication）**
为解决主从复制中从库单线程回放导致的延迟，MySQL从 5.6~8.0 持续增强复制并行度。

三代方案：

1. **5.6 库级复制（Schema-based）**
   不同库可并行，同一库串行 → 实用性极弱。

2. **5.7 基于组提交的并行复制（MTS / Group Commit）**
   根据主库组提交中的事务冲突关系，在从库并行回放。

3. **8.0 WriteSet 并行复制**
   基于事务更新的行级哈希判断冲突，不依赖主库并发度，更精准更强大。

</details>

<details>
<summary>② 原理</summary>

### 5.6 库级并行

* 同库事务必定串行，无法解决绝大多数 业务场景。
* 多库业务才能收益。

### 5.7 组提交并行

* 主库事务在进入 Prepare 阶段会形成一个“组”。
* 一个组中多个事务必然 **互不冲突**（否则不能一起 Prepare）。
* 从库据此可同时使用多个 SQL 线程并行执行组内事务。
* 并行度与主库并发度强相关。

### 8.0 WriteSet 并行复制

* 对每个事务涉及的 **主键/唯一键值** 做哈希 → 得到 WriteSet。
* 通过 WriteSet 判断不同事务是否修改同一行数据：

    * 冲突 → 串行
    * 不冲突 → 并行
* 即使主库串行提交，只要事务互不影响，从库仍能并行执行。
* 并行度真正由业务数据冲突情况决定，而非主库压力。

</details>

<details>
<summary>③ 关键点</summary>

* 并行复制的本质——判断事务是否可并行执行（无行级冲突）。
* 组提交依赖主库并行度，WriteSet 不依赖。
* WriteSet 使用 PK/UK 哈希做冲突检测 → 高效、精准。
* 并行复制主要用于减少主从延迟，提高吞吐。
* 冲突的事务必须串行，否则破坏一致性。
* last_committed 与 WriteSet 用于给从库提供执行顺序依赖关系。

</details>

<details>
<summary>④ 扩展知识</summary>

* MySQL 并行复制中 **slave_parallel_workers** 可控制从库 SQL 执行线程数。
* 单库热点写入冲突多 → 并行收益有限（本质是业务写入冲突高）。
* 主从延迟的主要来源：

    * 大事务
    * 行级冲突导致的串行执行
    * 从库 IO 或 CPU 不足
* WriteSet 支持的哈希算法：XXHASH64（默认）、MURMUR32。

</details>

---

## 3）面试官追问（Q&A）

**问：为什么单线程复制会导致主从延迟？**
答：主库高并发写入，但从库只能顺序回放，一旦主库写压力增加，从库就跟不上。

**问：组提交为什么能用于并行复制？**
答：同一组内的事务在主库已证明不存在锁冲突，因此从库可安全并行执行。

**问：WriteSet 如何判断两个事务能否并行？**
答：比较两个事务更新行的主键/唯一键哈希，若无重叠即认为无冲突。

**问：为什么说 5.6 库级并行几乎没用？**
答：绝大多数业务是单库多表，5.6 模式下单库内部仍是串行。

**问：WriteSet 与组提交相比最大的改进？**
答：不依赖主库同时进入 Prepare 的时机，精准检测冲突，允许更多并行。

**问：高并发写热点表用并行复制效果如何？**
答：热点表冲突多，WriteSet 会判断冲突，从库仍需串行，效果有限。

**问：并行复制会影响一致性吗？**
答：不会。所有并行执行皆基于冲突检测与 last_committed 依赖保证顺序一致。

**问：如何调优并行复制？**
答：增加 slave_parallel_workers、减少大事务、按主键顺序写入减少 WriteSet 冲突。

---

## 4）示意图（ASCII）

### MySQL 各版本并行复制演进

```
5.6: Schema-based
    +-----------------------+
    | db1 → worker1         |
    | db2 → worker2         |
    | 单库 = 串行           |
    +-----------------------+

5.7: Group Commit MTS
    +----------------------------------+
    | 组提交组 G1: tx1 tx2 tx3 (无冲突)|
    | 从库并行执行                     |
    +----------------------------------+

8.0: WriteSet
    +----------------------------------------+
    | 计算 tx 的 writeset = hash(PK/UK)      |
    | 无交集 → 并行执行                      |
    | 有交集 → 串行执行                      |
    +----------------------------------------+
```

### WriteSet 并行判定示意

```
事务 A 更新 {pk=1, pk=3}
事务 B 更新 {pk=5}
事务 C 更新 {pk=3}

WriteSet:
A = {H1, H3}
B = {H5}
C = {H3}

可并行：A 与 B
不可并行：A 与 C (冲突)
```

---

（总结完毕）
