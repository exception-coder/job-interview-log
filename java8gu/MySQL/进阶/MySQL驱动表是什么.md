总结标题
MySQL_Driving_Table_Selection

---

## 1）10 行极简速记版（纯文本）

✔ 驱动表=JOIN 循环的起点表
🔥 驱动表先读，被驱动表后读
📌 小表优先做驱动表（减少外层循环）
➤ 能用索引过滤的表更容易被选为驱动表
🔍 WHERE 过滤强的表更适合作驱动表
⚠️ LEFT JOIN 必然左表优先，但优化器可重写
📈 INNER JOIN 由优化器自动挑“小+可过滤”表
🧠 看执行计划：第一行就是驱动表
🚀 STRAIGHT_JOIN 可强制指定驱动顺序
✘ 盲目强制驱动表可能反向恶化性能

---

## 2）折叠式知识卡片版（Markdown）

<details>
<summary>① 定义</summary>

**驱动表（Driving Table）**：
在 Nested Loop Join 中，外层循环首先扫描的表，其行结果将一行行作为条件去匹配另一张表（被驱动表）。

**被驱动表（Driven Table）**：
内层循环被逐条访问的表，根据驱动表提供的条件进行查找。

</details>

<details>
<summary>② 原理</summary>

* MySQL 默认使用 **Nested Loop Join**（无 Hash Join 时）。
* 执行顺序：驱动表先扫描 → 将行作为条件 → 被驱动表查找匹配。
* 选择驱动表的核心目的是**减少外层循环次数**，直接影响整体复杂度。
* 优化器基于统计信息（行数、过滤条件、索引、连接类型等）决定驱动表。

</details>

<details>
<summary>③ 关键点</summary>

* **表大小**：小表优选，减少循环次数。
* **可用索引**：具备索引可显著降低匹配开销。
* **过滤性（selectivity）**：WHERE 条件能显著缩小结果集的表优先。
* **连接类型**：

    * LEFT JOIN：左表优先
    * RIGHT JOIN：右表优先
    * INNER JOIN：优化器自动选择小且过滤性好的表
* 使用 EXPLAIN：**第一行即驱动表**。
* STRAIGHT_JOIN 可强制指定顺序（仅适用于内连接）。

</details>

<details>
<summary>④ 扩展知识</summary>

* 当右表数据量远小于左表，优化器可重写 join 顺序，不严格遵循语法书写顺序。
* 对于无索引 join，小表驱动大表意义有限，因为都是全表扫描。
* MySQL 8.0 有更强的基于成本的优化器（Cost-Based Optimizer），对驱动表判断更精确。
* 强制 STRAIGHT_JOIN 在统计信息不准确时才有价值。

</details>

---

## 3）面试官追问（Q&A）

**问：驱动表选择的本质目标是什么？**
答：减少外层循环次数，从而降低整体 Nested Loop Join 的复杂度。

**问：为什么小表更适合做驱动表？**
答：外层循环次数取决于驱动表行数，小表可显著减少内层匹配次数。

**问：WHERE 条件为什么影响驱动表选择？**
答：过滤强的表能减少有效行，从而大幅减少外层循环量。

**问：如果两表都没有索引，该如何选择驱动表？**
答：Join 可能退化为笛卡尔积，小表驱动大表效果极弱；优化器主要依据表大小选择。

**问：LEFT JOIN 是否永远左表驱动？**
答：语义上是，但优化器可在右表极小或能强索引过滤时重写计划。

**问：如何强制指定驱动表？**
答：使用 STRAIGHT_JOIN，让 MySQL 按书写顺序执行 join。

**问：EXPLAIN 中如何判断驱动表？**
答：多表 join 情况下，输出顺序中第一行对应驱动表，其余依次被驱动。

**问：统计信息不准会导致什么问题？**
答：优化器可能选错驱动表，导致 join 执行计划质量下降，出现慢 SQL。

---

## 4）示意图（ASCII）

```
           Nested Loop Join 执行流程

          [Driving Table A]
                 |
          A.row1 -----> probe B
                 |
          A.row2 -----> probe B
                 |
          A.rowN -----> probe B

  A = 驱动表（外层循环）
  B = 被驱动表（内层查找）
```

```
EXPLAIN 输出示例（顺序代表执行顺序）

+----+-------+--------+
| id | table | type   |
+----+-------+--------+
| 1  | A     | ALL    |  <-- 驱动表
| 1  | B     | ref    |  <-- 被驱动表
+----+-------+--------+
```

---

（总结完毕）
