Query_Execution_Order
✔ SQL 的执行顺序和写法完全不同
📌 FROM→JOIN→WHERE→GROUP→HAVING→SELECT 是核心链路
🧠 逻辑执行顺序不等于物理执行顺序（优化器会改写）
🔥 WHERE 先于 GROUP BY，HAVING 作用于分组后
➤ ORDER BY 在 SELECT 之后执行
🚀 LIMIT 永远是最后一步
⚠️ 多表 JOIN 的顺序由优化器决定，不按书写顺序走
✨ DISTINCT 在 SELECT 之后但 ORDER BY 之前

---

## 折叠式知识卡片版

<details>
<summary>① 定义</summary>

* 文档说明了 **SQL 查询的逻辑执行顺序**，与开发者编写 SQL 的语序完全不同。
* 逻辑顺序描述数据库如何 **逐步裁剪数据集**，最终得到结果。
* 实际物理执行顺序可能被优化器重写，但逻辑顺序对理解 SQL 行为非常关键。

</details>

<details>
<summary>② 原理</summary>

### SQL 查询的逻辑执行顺序（InnoDB）

1. **FROM**：确定参与的表
2. **JOIN**：执行表连接，优化器决定连接顺序
3. **WHERE**：基于行级条件过滤
4. **GROUP BY**：按字段分组
5. **HAVING**：基于分组结果过滤
6. **SELECT**：选择最终输出列
7. **DISTINCT**（如有）去重
8. **ORDER BY**：结果排序
9. **LIMIT**：裁剪输出行数

### 为什么说是“逻辑顺序”？

* 真实执行路径可能经过索引跳跃、提前过滤、合并步骤等优化。
* 但最终语义效果必须保持逻辑顺序一致。

</details>

<details>
<summary>③ 关键点</summary>

* **WHERE 在 GROUP BY 之前**：不能在 WHERE 中使用聚合函数。
* **HAVING 在 GROUP BY 之后**：可对聚合结果过滤。
* **JOIN 顺序由优化器决定**：不按书写顺序执行。
* **ORDER BY 可能复用 GROUP BY 的排序**，减少排序成本。
* **LIMIT 最后执行**，意味着前面的排序/分组可能已消耗大量资源。
* **DISTINCT 在 SELECT 之后执行**：先选列，再去重。

</details>

<details>
<summary>④ 扩展知识</summary>

* 优化器（CBO）会根据统计信息、索引、过滤率重写执行计划（合理补充）。
* InnoDB 执行层可能提前使用索引裁剪数据，使物理顺序没那么严格（合理补充）。
* 对 ORDER BY + LIMIT 的优化（如 Top-N 优化）可显著提高性能（合理补充）。

</details>

---

## 面试官追问（Q&A）

**问：为什么 WHERE 不能用聚合函数？**
答：WHERE 在分组前执行，此时还没有聚合结果，只能过滤原始行。

**问：HAVING 和 WHERE 的本质区别是什么？**
答：WHERE 作用在行级，HAVING 作用在分组结果；HAVING 可使用聚合函数。

**问：JOIN 顺序是按书写顺序执行吗？**
答：不是，优化器会根据统计信息重新安排 JOIN 顺序以减少代价。

**问：为什么 LIMIT 是最后执行？**
答：需要在排序/分组完成后才能裁剪，否则结果不正确。

**问：ORDER BY 和 GROUP BY 会共享排序吗？**
答：当两者字段一致时，MySQL 可以复用排序，避免两次排序。

**问：DISTINCT 为什么在 SELECT 之后？**
答：先决定输出哪些列，才能判断哪些行是重复的。

---

## 示意图（ASCII）

```
逻辑执行顺序（从大表到最终结果）

FROM 
  ↓
JOIN 
  ↓
WHERE 
  ↓
GROUP BY 
  ↓
HAVING 
  ↓
SELECT 
  ↓
DISTINCT 
  ↓
ORDER BY 
  ↓
LIMIT
```

（完）
