✔ 快照读走 MVCC，读历史版本
🚀 当前读读最新版本，必加锁
📌 普通 SELECT 默认是快照读
🧠 FOR UPDATE/锁查询属于当前读
⚠️ RR 启动时定快照，RC 每次重建
🔥 快照读高并发但读到旧值
🔍 当前读触发行锁/间隙锁
📈 RC 可读到其他事务新提交
➤ RR 保证可重复读靠稳定快照
✔ 增删改全部强制当前读路径

---

## 2）折叠式知识卡片版

<details>
<summary>定义</summary>

* **快照读**：基于 MVCC 从 Undo 链读取历史版本，无锁；普通 `SELECT` 默认行为。
* **当前读**：读取最新行版本并加锁，包含加锁 SELECT、`INSERT/UPDATE/DELETE` 等修改类操作。

</details>

<details>
<summary>原理</summary>

* 快照读依赖 **Read View + Undo 版本链** 判定可见性。
* RR：Read View 在事务开始时固定，不随外部提交变化。
* RC：每次读都重新生成 Read View，总是读最新已提交。
* 当前读：直接访问当前行版本，并在访问路径上加记录锁/间隙锁/Next-Key Lock。

</details>

<details>
<summary>关键点</summary>

* 快照读不阻塞写，写也不阻塞快照读。
* 当前读保证并发修改正确性，会产生锁竞争。
* RR 依赖稳定快照实现可重复读；RC 重视实时性。
* 增删改一定是当前读，无法使用快照读路径。

</details>

<details>
<summary>扩展知识</summary>

* RR 下当前读的 Next-Key Lock 可避免幻读。
* 快照读长事务易导致 Undo 积压。
* RC 更实时但热点写竞争更明显。
* 二级索引快照读仍需回表取主键对应版本。

</details>

---

## 3）面试官追问（Q&A）

**问：为什么普通 SELECT 是快照读？**
答：为提升读写并发，通过 MVCC 直接读取版本链，无需加锁。

**问：当前读必须加锁的原因？**
答：确保读取的最新行不会被并发事务修改，保证更新路径的正确性。

**问：RR 下为什么快照不更新？**
答：为实现可重复读，一旦建立 Read View 后所有快照读必须保持一致。

**问：RC 为什么每次都重建快照？**
答：RC 隔离级别要求总是读取最新提交数据，因此必须重建 Read View。

**问：快照读能否避免幻读？**
答：不能，快照读只解决版本可见性，范围稳定性需依赖当前读的 Next-Key Lock。

**问：当前读涉及哪些锁？**
答：记录锁、间隙锁、Next-Key Lock，具体由访问路径和优化器判断。

**问：Undo 链在快照读中的作用？**
答：提供历史版本，使事务能根据可见性规则读取正确的旧版本。

**问：增删改为何无法走快照读？**
答：写操作必须基于最新版本修改，不可能基于历史版本进行变更。

---

## 4）示意图（ASCII）

```
         +-------------------------------+
         |            SQL 查询           |
         +-------------------------------+
                       |
          +------------+-------------+
          |                          |
     快照读（MVCC）              当前读（加锁）
          |                          |
  Read View 判可见性          加记录锁/间隙锁
  读取 Undo 版本链           读取最新 row 版本
          |                          |
          +------------+-------------+
                       |
                 返回结果集
```
