总结标题：sql_execution_plan_key_points

---

## 1）10 行极简速记版（纯文本）

✔ 执行计划核心字段：type / key / rows / extra
🔥 type 决定访问路径性能等级
📌 possible_keys ≠ 实际使用索引
➤ key 才是最终使用的索引
⚠️ Using filesort / Using temporary 是性能警告
🚀 覆盖索引出现 Using index 性能最佳
🧠 rows 预估扫描行数，越小越快
🔍 filtered% 反映过滤效果
✨ extra 是高频性能瓶颈定位点
📈 index < range < ref < eq_ref < const < system

---

## 2）折叠式知识卡片版（Markdown）

<details>
<summary>定义</summary>

SQL 执行计划（EXPLAIN）用于展示 MySQL 优化器为一条 SQL 所选择的执行路径，包含索引使用情况、扫描方式、排序策略、分组方式等关键信息，是 SQL 性能分析的核心工具。

</details>

<details>
<summary>原理</summary>

* EXPLAIN 输出 12 项字段，包括 id、select_type、table、type、possible_keys、key、rows、filtered、extra 等。
* 优化器基于统计信息选择索引、访问路径、连接算法，并通过执行计划反映其决策。
* type 字段从系统表到全表扫描，反映 IO 成本顺序；extra 表示执行过程中的额外操作，如排序、临时表、索引下推等。
* rows + filtered 决定实际读取多少行，是估算真实成本的关键指标。

</details>

<details>
<summary>关键点</summary>

**1）type（访问方法）性能排序（由快到慢）：**
`system > const > eq_ref > ref > range > index > ALL`

* eq_ref：唯一索引等值 join，非常快
* ref：普通索引等值过滤
* range：范围扫描
* index：扫描整棵索引树
* ALL：全表扫描

**2）possible_keys 与 key**

* possible_keys：优化器“可能考虑”用到的索引
* key：实际使用的索引（只有它才算真正走了索引）

**3）rows + filtered**

* rows：预估扫描行数
* filtered：行过滤比例
* rows * filtered ≈ 实际输出行数

**4）extra 信息非常关键：**

* Using where：索引未完全过滤，需要额外过滤
* Using index：覆盖索引，不回表
* Using index condition：使用索引下推
* Using temporary：建立临时表，多见于 group by
* Using filesort：无法使用索引排序，性能警告
* Using join buffer：join 无法走索引
* Using index for group-by / order-by：说明分组/排序可复用索引（极佳）

</details>

<details>
<summary>扩展知识</summary>

* 判断是否真正使用索引：看 key + type + extra 的组合，而不是 possible_keys。
* 最左前缀原则影响是否能使用 composite index。
* 覆盖索引可避免回表，是最常见且最显著的性能优化手段。
* Using filesort / Using temporary 是慢 SQL 的高危信号，应重点排查字段顺序与索引。
* 直方图（histogram）可提升优化器估算精度，从而提升索引选择质量。

</details>

---

## 3）面试官追问（Q&A）

**问：如何判断是否真正走到索引？
答：看 key 是否有值，并结合 type（不能是 ALL/index），extra 中不能只有 Using where。**

**问：possible_keys 和 key 的差别是什么？
答：possible_keys 是候选列表，key 是最终选择；只有 key 才是实际使用。**

**问：type=range 和 type=ref 的核心区别是什么？
答：range 进行范围过滤，扫描多条；ref 是等值过滤，扫描更少行。**

**问：出现 Using filesort 一定意味着慢吗？
答：大概率会影响性能，但 small result + limit 时影响可能较小。**

**问：filtered% 低意味着什么？
答：筛选条件效率差，rows 高但 filtered 小通常表示大量无效扫描。**

**问：Using index condition 是什么优化？
答：索引下推（ICP），在索引层过滤部分条件，减少回表次数。**

**问：为什么 type=index 比 ALL 好不了多少？
答：index 是扫描整棵索引树，与全表扫描一样是大量 IO，只是页更小。**

**问：Using temporary 的典型场景？
答：group by 无法使用索引、order by 难以复用索引。**

**问：rows 估算可能不准，怎么办？
答：更新统计信息、使用更高区分度的字段、必要时 FORCE INDEX。**

---

## 4）示意图（ASCII）

```
执行计划关注路径图

           +----------------------------------+
           |             EXPLAIN              |
           +----------------+-----------------+
                            |
                            v
        +-------------------+----------------------+
        |        基本字段信息（id/table/type）     |
        +-------------------+----------------------+
                            |
                            v
      +--------------------------------------------+
      |   核心关注：type / key / rows / extra      |
      +-------------------+------------------------+
                            |
                            v
    +---------------------------------------------------------+
    | extra 中高危标志：Using filesort / Using temporary      |
    +---------------------------------------------------------+

结论：type 决定访问路径，key 决定是否走索引，
rows 决定扫描量，extra 暴露隐藏成本。
```

---
