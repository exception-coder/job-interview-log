### mysql_update_lock_behavior

#### 1）10 行极简速记版（纯文本）

✔ InnoDB 默认行锁，尽量避免表锁
📌 UPDATE 命中索引 → 精确行锁
🔥 无索引/条件模糊 → 扫描多行也仍是行锁
⚠️ 特殊情况下全表扫描可能退化成表锁
🧠 MyISAM UPDATE 永远是表锁
🔍 LOCK TABLES 显式请求必锁表
📈 行锁基于索引记录、间隙、next-key
✨ 未走索引时锁很多行但不是锁整表
🚀 合理建索引是避免锁冲突关键
✘ 忽视索引选择性会导致大量加锁

---

#### 2）折叠式知识卡片版

<details>
<summary>定义</summary>

MySQL（InnoDB）在执行 UPDATE 时优先采用行级锁，但在特定情况下会出现表锁或偏向表级锁的行为。锁粒度取决于是否命中索引、查询范围、存储引擎以及显式加锁操作。

</details>

<details>
<summary>原理</summary>

* InnoDB 的行级锁基于索引项实现，包括 record lock、gap lock、next-key lock。
* UPDATE 若命中索引，可直接定位行 → 仅锁定匹配行及相关间隙。
* 未命中索引需全表扫描，InnoDB 仍会逐行加 row lock，而非立即锁全表，但锁范围变大。
* 某些特殊场景（索引缺失 + 并发冲突）可能使锁升级或表现为锁表。
* MyISAM 不支持事务，UPDATE 必然是表锁。
* 显式 `LOCK TABLES` 会强制表锁，无论引擎类型。

</details>

<details>
<summary>关键点</summary>

* 行锁建立在索引上：无索引时需扫描大量记录。
* 全表扫描 ≠ 必然表锁，但锁范围大导致并发性能下降。
* 使用有效索引可显著减少锁冲突。
* Next-key lock 会锁定记录和间隙，用于防止幻读。
* 表锁常见来源：MyISAM、DDL、显式 LOCK TABLES、某些系统操作。

</details>

<details>
<summary>扩展知识</summary>

* gap lock 与 next-key lock 会在 RR 隔离级别出现，用于范围保护。
* 锁的对象不是“行”，而是“索引记录及其间隙”（文章链接有说明）。
* 索引选择性差可能导致过多行被锁，影响并发度。
* 无索引的 UPDATE 不仅性能差，还使锁范围不可控，易触发死锁。

</details>

---

#### 3）面试官追问（Q&A）

**问：UPDATE 没有索引会锁全表吗？
答：不一定。InnoDB 仍然是逐行加行锁，但由于扫描全表，实际锁定行数巨大，看起来像锁表。**

**问：为什么行锁依赖索引？
答：InnoDB 的行锁是锁索引项而不是物理行，没有索引就无法直接定位目标行。**

**问：MyISAM 为什么必须表锁？
答：它没有行级锁机制，也没有事务管理，只能通过表锁保证一致性。**

**问：什么情况 UPDATE 会触发表锁？
答：显式 LOCK TABLES、MyISAM 引擎、DDL 冲突、严重范围扫描导致的锁竞争。**

**问：UPDATE 走索引和不走索引的锁行为有何差别？
答：走索引锁少量记录；不走索引会扫描大量行并对其加锁，极易产生阻塞。**

**问：next-key lock 的作用是什么？
答：防止幻读，通过锁定索引记录及其间隙，保证范围稳定性。**

**问：如何减少 UPDATE 锁冲突？
答：建立高选择性索引、缩小更新范围、使用更精准的 WHERE 条件。**

---

#### 4）示意图（ASCII）

```
UPDATE 锁行为决策流程

         是否命中索引？
                │
      ┌─────────┴─────────┐
      │                   │
     是                   否
      │                   │
 精确定位记录         全表扫描
 行锁/next-key       多行行锁
      │                   │
 并发高，可控         锁范围大，易阻塞/看似表锁
```

```
InnoDB 锁粒度结构
Record Lock   → 锁索引记录
Gap Lock      → 锁间隙
Next-Key Lock → Record + Gap（左开右闭）
```

如需，我可以继续输出《UPDATE 典型死锁案例解析》《行锁退化场景深度分析》。
