✔ 悲观锁依赖数据库锁，先锁后改
🚀 乐观锁走版本号/CAS，不阻塞
📌 FOR UPDATE 是典型悲观锁路径
🧠 乐观锁更新时检查版本一致性
⚠️ 悲观锁强一致但并发差、易死锁
🔥 乐观锁失败需重试，业务需兜底
🔍 行锁基于索引，不走索引可能锁表
📈 乐观锁适合读多写少
➤ 悲观锁适合写多、高冲突场景
✔ 更新失败≠无锁，依旧有写冲突检测

---

## 2）折叠式知识卡片版

<details>
<summary>定义</summary>

* **悲观锁**：假设冲突必然发生，修改前先对记录加排他锁（X），阻塞并发写。
* **乐观锁**：假设冲突少，修改时才校验冲突（版本号/CAS），不依赖数据库行锁。

</details>

<details>
<summary>原理</summary>

### 悲观锁

* 依赖 InnoDB 行级锁（Record/Next-Key）。
* 使用 `SELECT ... FOR UPDATE` 加 X 锁，事务提交/回滚后释放。
* 锁冲突会等待或抛异常。
* 基于索引加锁，不走索引可能触发表锁。

### 乐观锁

* 使用 **version 字段 / quantity 校验**实现 CAS。
* 更新条件附带版本号：
  `UPDATE ... SET ... WHERE id=? AND version=?`。
* 若版本不匹配，更新失败，需业务重试。
* 不阻塞，适用于低冲突场景。

</details>

<details>
<summary>关键点</summary>

* 悲观锁保证强一致性，但会降低并发并产生锁等待。
* 乐观锁无加锁开销，但可能出现较高的更新失败率。
* 悲观锁是“先锁后改”；乐观锁是“先改再比对”。
* 乐观锁失败只是版本不匹配，不是非锁并发安全。
* 行锁必须命中索引；否则可能锁整表。

</details>

<details>
<summary>扩展知识</summary>

* 乐观锁适用于读多写少、电商库存扣减等非高冲突业务。
* 悲观锁适用于账号余额等高并发写敏感业务。
* 乐观锁避免死锁，但可能产生大量重试风暴。
* 悲观锁可与隔离级别联动（RR 会产生间隙锁）。
* 分布式场景下还可使用 Redis、ZK 等分布式锁代替数据库悲观锁。

</details>

---

## 3）面试官追问（Q&A）

**问：悲观锁为什么要关闭自动提交？**
答：因为锁必须在事务内保持，自动提交会使 SQL 执行完立即释放锁，无法保证隔离性。

**问：FOR UPDATE 为什么可能锁表？**
答：行级锁依赖索引，不走索引就会扫描所有记录 → 锁全表，严重影响并发。

**问：乐观锁是否真的“无锁”？**
答：不是。只是不用数据库行锁，而是用写时版本校验保证并发安全。

**问：乐观锁失败后怎么办？**
答：业务端需要重试或回滚流程，因此配套重试机制必不可少。

**问：悲观锁和隔离级别的关系？**
答：RR 会产生 Gap/Next-Key，悲观锁更容易造成范围锁扩大；RC 不会产生 gap 锁，并发性更好。

**问：什么时候选乐观锁更合适？**
答：读多写少、冲突概率低、允许重试的场景。

**问：悲观锁是否能完全避免并发写冲突？**
答：理论上能，但高并发下仍可能出现死锁，需要依赖死锁检测。

**问：乐观锁如何处理超卖？**
答：用版本号或库存条件确保只有未被更新的库存可减，失败时重试即可。

---

## 4）示意图（ASCII）

```
            +--------------------------+
            |      并发控制两种策略       |
            +--------------------------+
                   /              \
                  /                \
     悲观锁（PCC）                    乐观锁（OCC）
     - 先加锁                        - 先读版本
     - 阻塞并发                      - CAS 比对
     - 保证强一致                    - 冲突时重试
```
