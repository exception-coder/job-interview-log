✔ 共享锁只读不写，可并发
🚀 排他锁独占资源，读写皆可
📌 S 锁允许再加 S，禁止加 X
🧠 X 锁禁止任何其他锁进入
⚠️ LOCK IN SHARE MODE → S 锁
🔥 FOR UPDATE → X 锁
🔍 S 锁阻止写，X 锁阻止读写
📈 X 锁冲突最多，是更新路径核心
➤ S/X 冲突矩阵是并发控制基础
✔ 锁加在命中记录上，走索引生效

---

## 2）折叠式知识卡片版

<details>
<summary>定义</summary>

* **共享锁（Shared Lock, S）**：读锁，允许多个事务并发读取，不允许修改。
* **排他锁（Exclusive Lock, X）**：写锁，独占资源，阻塞其他事务的 S 和 X。

</details>

<details>
<summary>原理</summary>

* 加 `LOCK IN SHARE MODE` → 对命中记录加 **S 锁**。
* 加 `FOR UPDATE` → 对命中记录加 **X 锁**。
* **S 锁之间兼容**，S 锁与 X 锁 **不兼容**。
* **X 锁独占**：持有 X 锁的事务既能读也能写，其他事务无法对同一记录加任何锁。

</details>

<details>
<summary>关键点</summary>

* 共享锁保护读一致性，排他锁保护写独占性。
* S 锁适合需要读取但禁止并发写的场景。
* X 锁是更新类语句的标准路径（UPDATE/DELETE/INSERT）。
* S/X 均为行级锁，仍依赖索引命中，否则可能锁更大范围。
* 进入锁等待由锁兼容矩阵决定。

</details>

<details>
<summary>扩展知识</summary>

* S/X 仅控制记录级别，与**间隙锁/next-key 锁**等范围锁组合使用。
* S 锁不会阻止其他事务读取快照（MVCC 快照读不加锁）。
* X 锁通常伴随当前读路径，必须配合日志（undo/redo）保障一致性。
* 表级 S/X 需要依赖意向锁（IS/IX）协调加锁冲突。

</details>

---

## 3）面试官追问（Q&A）

**问：共享锁能否阻止幻读？**
答：不能，S 锁仅保护记录，不保护索引间隙；必须使用 next-key 才能避免幻读。

**问：为什么 FOR UPDATE 是排他锁？**
答：因为该查询意味着后续要修改数据，必须阻止其他事务读取最新记录并修改它。

**问：S 锁为何还允许并发？**
答：因为读取操作不会破坏数据一致性，可安全共享，因此数据库允许多个 S 共存。

**问：X 锁是否阻止快照读？**
答：不会，快照读不加锁，它读取历史版本，因此不会与 X 锁冲突。

**问：什么场景下 S 锁比 MVCC 更有意义？**
答：需要读最新值并保证读到的版本不被修改，如校验类逻辑。

**问：S/X 锁是否作用于索引？**
答：行级 S/X 锁加在命中的索引记录上；不走索引会锁更大范围甚至锁全表。

---

## 4）示意图（ASCII）

```
          +--------------------------+
          |      InnoDB 锁兼容性      |
          +------------+-------------+
                       |
      +----------------+----------------+
      |                                 |
   共享锁（S）                     排他锁（X）
      |                                 |
  可与 S 兼容                     与任何锁均冲突
      |                                 |
  只读不可写                     读写皆可，独占资源
      +---------------------------------+
```
