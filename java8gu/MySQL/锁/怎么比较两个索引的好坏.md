总结标题：mysql_index_comparison

---

## 1）10 行极简速记版（纯文本）

✔ 判断索引好坏，本质看“成本”
🔥 最直接方式：FORCE INDEX + 实际执行耗时
📌 MySQL 8.0 用 EXPLAIN ANALYZE，8.0 前用 SHOW PROFILES
🔍 执行计划核心指标：type、rows、Extra
🧠 rows 越小越好，type 越靠前越优（const/ref 最佳）
⚠️ Extra 出现 filesort/temporary 基本宣告索引失败
🚀 基数高的索引更可能成为最优索引
✨ 优化器有概率选错索引 → 必须手动验证
📈 单列 vs 单列对比：成本差异直接体现在扫描行数
✘ 仅靠 filtered 判断不可靠，不推荐关注

---

## 2）折叠式知识卡片版（Markdown）

<details>
<summary>定义</summary>

文档讨论如何判断两个可选索引中哪个更优。判断依据包括实际执行耗时（通过 FORCE INDEX 运行 SQL）以及执行计划的 cost 相关数据（type、rows、extra 等），最终目标是找到对当前 SQL 成本最低的索引。

</details>

<details>
<summary>原理</summary>

* **优化器选索引的依据是成本（cost）**：基于行数估算、选择性、回表成本等。
* **手动对比索引好坏的方式**：

    1. 使用 FORCE INDEX 强制走不同索引并测量真实耗时。
    2. 查看 EXPLAIN / EXPLAIN ANALYZE 对应的访问方式和扫描行数。
* **type 越精确成本越低**：const > eq_ref > ref > range > index > ALL。
* **rows 表示扫描行数，是优化器成本的重要输入**。
* **Extra 信息包含是否出现额外开销（如 filesort、temporary）**。

</details>

<details>
<summary>关键点</summary>

* FORCE INDEX 可强制单独验证单个索引的实际效果。
* rows 小通常意味着选择性高 → 最佳索引候选。
* 出现全表扫描（ALL）基本可判定索引无效。
* Extra 中若出现 Using filesort / Using temporary，说明排序或分组未走到索引。
* filtered 数据可参考，但优化器估算误差大，因此不建议作为主判断指标。
* MySQL 8.0 推荐使用 EXPLAIN ANALYZE 获取真实执行成本。
* 优化器可能会选错索引，因此人工验证必要。

</details>

<details>
<summary>扩展知识</summary>

* 索引基数（Cardinality）越高通常效果越好。
* SQL 条件的顺序不影响优化器选择索引，但组合条件会影响 selectivity。
* 可考虑使用复合索引替代多个单列索引避免优化器误判。
* EXPLAIN 中 rows 与 filtered 的估算依赖统计信息，若不准可执行 ANALYZE TABLE。
* 执行计划只是估算，真正的性能判断应依赖真实运行数据。

</details>

---

## 3）面试官追问（Q&A）

**问：为什么优化器会选错索引？**
答：因为其成本估算依赖统计信息（Cardinality、行数估算），如果统计信息陈旧或分布不均，会误判索引选择。

**问：判断索引好坏最核心的指标是什么？**
答：扫描行数（rows）与访问类型（type）。两者综合反映索引选择性与执行成本。

**问：为什么 filtered 不适合作为核心判断指标？**
答：filtered 是估算值，误差可能极大，特别是数据分布不均时，会误导分析。

**问：FORCE INDEX 的最佳使用场景是什么？**
答：优化器选错索引时，用其验证不同索引的真实执行耗时以反向推断最佳索引。

**问：EXPLAIN ANALYZE 比 EXPLAIN 更可靠的原因？**
答：EXPLAIN ANALYZE 会真实执行 SQL 并记录实际耗时、行数与 loops，更接近真实情况。

**问：单列索引与复合索引如何判断哪个好？**
答：看复合索引是否满足最左前缀原则，以及其是否能减少回表次数；扫描行数通常明显更少。

**问：Extra 中哪类提示信息代表索引效果差？**
答：“Using filesort”“Using temporary”“Using index condition (range large)” 等代表额外排序/临时表操作，通常表示索引未充分利用。

**问：基数高的索引为什么更优？**
答：基数高意味着选择性好，扫描行数减少，回表成本最低。

---

## 4）示意图（ASCII）

```
           比较两个索引好坏流程
┌─────────────────────────┐
│ SQL 可走多个索引？      │
└───────────────┬─────────┘
                ▼
       FORCE INDEX 分别运行
        │              │
        ▼              ▼
   记录执行耗时     记录执行耗时
        │              │
        └───────┬──────┘
                ▼
        EXPLAIN / ANALYZE
                │
     对比 type / rows / Extra
                ▼
         选择成本最低的索引
```
