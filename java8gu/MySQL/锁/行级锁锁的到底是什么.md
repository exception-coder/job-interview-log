✔ 行锁本质锁“索引项”，不是锁“行数据”
🚀 Next-Key = 记录锁 + 间隙锁，RR 下默认加它
📌 唯一等值查询会退化成行锁
🧠 非唯一/范围查询会锁扫描到的整个范围
⚠️ Gap Lock 只锁可插入区间，不锁记录
🔥 RR 中所有锁定读都可能锁范围
🔍 加锁只发生在访问到的索引项上
📈 唯一索引范围查询会多锁一个“不满足条件”的点（历史 bug）
➤ 覆盖索引查询不会给主键索引加锁
✔ id 不存在时也会锁所在间隙区间

---

## 2）折叠式知识卡片版

<details>
<summary>定义</summary>

* **Record Lock（记录锁）**：加在具体索引记录上的锁。
* **Gap Lock（间隙锁）**：加在索引记录之间的可插入区间上的锁。
* **Next-Key Lock**：Record Lock + Gap Lock（左开右闭），RR 隔离级别下默认加锁单位。
* **行级锁本质**：锁的是“索引记录”，而不是物理行；未走索引会锁全表。

</details>

<details>
<summary>原理</summary>

* 在 **RR 隔离级别** 下，锁定读（`SELECT … FOR UPDATE`、`UPDATE`、`DELETE`、`LOCK IN SHARE MODE`）会根据访问路径对扫描到的索引范围加 Next-Key/GAP/Record 锁。
* **唯一等值条件 + 唯一索引** → Next-Key 退化为 Record Lock。
* **非唯一索引或范围扫描** → 锁完整 next-key 区间，阻止插入新记录避免幻读。
* 扫描时 InnoDB 会继续遍历到 **第一个不满足条件的值**，导致额外 next-key 被锁（官方称 bug）。
* 覆盖索引可避免回表，因此不会在主键索引上加锁。

</details>

<details>
<summary>关键点</summary>

* 加锁规则强调 **访问到什么就锁什么**（原则 2）。
* Next-Key 是 RR 幻读防护的核心机制。
* Gap Lock 不影响已有行，只阻止插入。
* 等值查询满足条件会退化为行锁，提高并发性（优化 1）。
* 等值查询右侧第一个不满足条件项 → gap 锁（优化 2）。
* 没有匹配行时，依然会锁该值所在的 gap 区间。

</details>

<details>
<summary>扩展知识</summary>

* 在 RC 隔离级别，Gap/Next-Key 基本不启用，因此范围幻读风险由 MVCC 承担。
* 扫描范围越大，Next-Key 锁越多，越容易造成锁等待甚至死锁。
* 隐式主键（row_id）会在无主键表中被用作加锁依据。
* 若 SQL 不使用索引，InnoDB 会扫描全表 → 加锁风险拉满。

</details>

---

## 3）面试官追问（Q&A）

**问：为什么说 InnoDB 的行锁其实是“索引锁”？**
答：InnoDB 的加锁点位于 B+Tree 节点，锁住的是索引项；数据行只是由聚簇索引指向，因此不锁索引就无法锁行。

**问：Gap Lock 为什么不锁记录？**
答：它的目的仅是阻止插入新行来避免幻读，无需阻塞现有记录的读写。

**问：Next-Key 为什么是左开右闭？**
答：因为锁的重点是“当前记录 + 之前的间隙”，保证索引扫描连续性并防止插入当前值。

**问：唯一等值查询为何退化为行锁？**
答：唯一索引的等值，定位单条记录，无需锁区间，提高并发能力。

**问：覆盖索引查询为什么不锁主键？**
答：因为查询不访问主键索引页面，根据原则 2，“未访问不加锁”。

**问：无命中（记录不存在）会锁哪里？**
答：锁落在“该值应当出现的 gap 区间”，用于阻止其他事务在这个 gap 中插入新行。

**问：RR 与 RC 在行锁上的差异？**
答：RC 不启用 gap/next-key，因此范围查询不会锁间隙；RR 会锁范围来避免幻读。

**问：唯一索引范围查询为何会锁到不满足条件的第一个值？**
答：实现缺陷（官方称 bug），InnoDB 会继续遍历到下一条索引项才能终止，导致额外加锁。

---

## 4）示意图（ASCII）

```
索引值： 5 ---- 10 ---- 15 ---- 20 ---- +∞

Record Lock:       [10]
Gap Lock:      (5,10)  (10,15)  (15,20)  (20,+∞)
Next-Key:      (5,10]  (10,15]  (15,20]  (20,+∞]

RR 下加锁示例：
SELECT ... FOR UPDATE WHERE id=7
=> 无记录 7，锁 (5,10)

SELECT ... FOR UPDATE WHERE id>=10 AND id<11
=> 加 [10] 行锁 + (10,15] next-key
```
