Ali_Seckill_DB_Principle
✔ 热点扣减仍基于 MySQL，以一致性为前提
🔥 阿里自研补丁：Inventory Hint
📌 核心是“热点行分组 + 双执行单元并行”
🧠 降低行锁竞争、索引遍历、事务提交次数
🚀 Row Cache 缓存热点行避免重复 B+Tree 查找
⚠️ 仅阿里自研 MySQL / RDS 支持这些 Hint
➤ statement queue 进一步限流热点语句
✨ 秒杀抗压本质：特定场景的特定优化

---

## 折叠式知识卡片版

<details>
<summary>① 定义</summary>

* 阿里在 MySQL 上加入 **Inventory Hint** 补丁，用于应对秒杀场景的热点行更新。
* 基于主键或唯一键相同的 UPDATE 请求，会被自动分组、批处理、组提交。
* 核心目标：让 MySQL **安全、高一致**地承受高并发扣减，而不依赖 Redis 侧扣减。

</details>

<details>
<summary>② 原理</summary>

### Hint 语法（阿里专有）

```
UPDATE /*+ COMMIT_ON_SUCCESS ROLLBACK_ON_FAIL TARGET_AFFECT_ROW(1)*/ T
SET c = c - 1 WHERE id = 1;
```

* **COMMIT_ON_SUCCESS**：SQL 成功即提交事务。
* **ROLLBACK_ON_FAIL**：失败即回滚事务。
* **TARGET_AFFECT_ROW(n)**：影响行数必须等于 n 否则失败。

### 热点行识别 + 分组

带有上述 Hint 的 SQL 会被 MySQL 内核判定为热点更新。
内核在时间窗口内按主键分组，同一热点行的更新进入同一 Group。

### 双执行单元（Dual Processor）

两个执行单元交替：

* Unit A 收集 → 提交
* Unit B 同时开始下一轮收集
  实现 pipeline 化处理，提高热点行吞吐。

### 三大优化点（关键）

1. **减少行锁等待**

    * Leader SQL 获取行锁
    * 同组 Follower 不需要重复等待，大幅降低锁冲突。

2. **减少 B+Tree 遍历**

    * Leader 遍历一次定位记录后，行放入 **Row Cache**
    * Follower 直接在内存 Row Cache 修改，避免重复索引查找。

3. **减少事务提交次数**

    * 一组 SQL 合并成一次组提交（Group Commit）
    * 提高日志写入效率，减轻 redo 压力。

</details>

<details>
<summary>③ 关键点</summary>

* 并不是“高并发万能药”，但对热点扣减场景极其有效。
* 行锁冲突降低、索引减少、提交减少 = TPS 大幅提升。
* 仅在阿里 MySQL / 阿里云 RDS 实际支持（Hint 语法为私有扩展）。
* 秒杀系统的“稳”本质来自数据库层的强一致更新能力，而非缓存削峰方案。

</details>

<details>
<summary>④ 扩展知识</summary>

### Statement Queue

* 按桶隔离热点 SQL，限制每桶并发度，减少冲突。
* 用于进一步提升整体性能与并发可控性。

（文档简单提及，此处为结构化补充）

</details>

---

## 面试官追问（Q&A）

**问：为什么阿里不采用 Redis 扣减？**
答：Redis 扣减存在一致性问题（超卖/少卖），业务核心库存必须由强一致的 MySQL 来扣。

**问：Inventory Hint 如何减少锁竞争？**
答：组内 Leader 获取锁后，Follower 直接复用，不再重复排队。

**问：Row Cache 对秒杀有什么作用？**
答：热点行只需要首次 B+Tree 定位，后续所有更新都走内存，避免多次索引查找。

**问：为什么需要两个执行单元？**
答：形成 Pipeline，使收集与提交并行，提高吞吐。

**问：TARGET_AFFECT_ROW 有什么用？**
答：避免竞争情况下“脏成功”，只有影响行数正确才算扣减成功。

**问：组提交怎么提升性能？**
答：多条 SQL 合并一次 redo/fsync，极大减少 IO 操作。

**问：Statement Queue 与 Inventory Hint 如何配合？**
答：Hint 解决热点行内部优化，Queue 解决系统整体并发保护。

---

## 示意图（ASCII）

```
     热点行更新流程 (Inventory Hint)

 Requests →
   [Group By PK] → [Unit A 收集] → 提交
                      ▲               │
                      │               ▼
                [Unit B 收集] ← 轮换执行

 组内处理流程：
      Leader → 获取行锁 → B+Tree 定位 → Row Cache
      Followers → 直接修改 Row Cache → 合并提交
```

（完）
